// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (
    alliance_id,
    corporation_id,
    description,
    faction_id,
    last_login_at,
    mail_updated_at,
    name,
    security_status,
    skill_points,
    solar_system_id,
    wallet_balance,
    id,
    birthday,
    gender
)
VALUES (
    ?, ?, ?, ?, ? ,?, ?, ?, ?, ?, ? ,?, ?, ?
)
RETURNING alliance_id, birthday, corporation_id, description, gender, faction_id, id, last_login_at, mail_updated_at, name, security_status, skill_points, solar_system_id, wallet_balance
`

type CreateCharacterParams struct {
	AllianceID     sql.NullInt64
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	LastLoginAt    time.Time
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    int64
	SolarSystemID  int64
	WalletBalance  float64
	ID             int64
	Birthday       time.Time
	Gender         string
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.AllianceID,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.LastLoginAt,
		arg.MailUpdatedAt,
		arg.Name,
		arg.SecurityStatus,
		arg.SkillPoints,
		arg.SolarSystemID,
		arg.WalletBalance,
		arg.ID,
		arg.Birthday,
		arg.Gender,
	)
	var i Character
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.LastLoginAt,
		&i.MailUpdatedAt,
		&i.Name,
		&i.SecurityStatus,
		&i.SkillPoints,
		&i.SolarSystemID,
		&i.WalletBalance,
	)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.last_login_at, characters.mail_updated_at, characters.name, characters.security_status, characters.skill_points, characters.solar_system_id, characters.wallet_balance, corporations.id, corporations.category, corporations.name, alliances.id, alliances.category, alliances.name, factions.id, factions.category, factions.name, systems.id, systems.category, systems.name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
JOIN eve_entities AS systems ON systems.id = characters.solar_system_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
WHERE characters.id = ?
`

type GetCharacterRow struct {
	AllianceID     sql.NullInt64
	Birthday       time.Time
	CorporationID  int64
	Description    string
	Gender         string
	FactionID      sql.NullInt64
	ID             int64
	LastLoginAt    time.Time
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    int64
	SolarSystemID  int64
	WalletBalance  float64
	ID_2           int64
	Category       string
	Name_2         string
	ID_3           sql.NullInt64
	Category_2     sql.NullString
	Name_3         sql.NullString
	ID_4           sql.NullInt64
	Category_3     sql.NullString
	Name_4         sql.NullString
	ID_5           int64
	Category_4     string
	Name_5         string
}

func (q *Queries) GetCharacter(ctx context.Context, id int64) (GetCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, id)
	var i GetCharacterRow
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.LastLoginAt,
		&i.MailUpdatedAt,
		&i.Name,
		&i.SecurityStatus,
		&i.SkillPoints,
		&i.SolarSystemID,
		&i.WalletBalance,
		&i.ID_2,
		&i.Category,
		&i.Name_2,
		&i.ID_3,
		&i.Category_2,
		&i.Name_3,
		&i.ID_4,
		&i.Category_3,
		&i.Name_4,
		&i.ID_5,
		&i.Category_4,
		&i.Name_5,
	)
	return i, err
}

const listCharacterIDs = `-- name: ListCharacterIDs :many
SELECT id
FROM characters
`

func (q *Queries) ListCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.last_login_at, characters.mail_updated_at, characters.name, characters.security_status, characters.skill_points, characters.solar_system_id, characters.wallet_balance, corporations.id, corporations.category, corporations.name, alliances.id, alliances.category, alliances.name, factions.id, factions.category, factions.name, systems.id, systems.category, systems.name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
JOIN eve_entities AS systems ON systems.id = characters.solar_system_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
ORDER BY characters.name
`

type ListCharactersRow struct {
	AllianceID     sql.NullInt64
	Birthday       time.Time
	CorporationID  int64
	Description    string
	Gender         string
	FactionID      sql.NullInt64
	ID             int64
	LastLoginAt    time.Time
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    int64
	SolarSystemID  int64
	WalletBalance  float64
	ID_2           int64
	Category       string
	Name_2         string
	ID_3           sql.NullInt64
	Category_2     sql.NullString
	Name_3         sql.NullString
	ID_4           sql.NullInt64
	Category_3     sql.NullString
	Name_4         sql.NullString
	ID_5           int64
	Category_4     string
	Name_5         string
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersRow
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(
			&i.AllianceID,
			&i.Birthday,
			&i.CorporationID,
			&i.Description,
			&i.Gender,
			&i.FactionID,
			&i.ID,
			&i.LastLoginAt,
			&i.MailUpdatedAt,
			&i.Name,
			&i.SecurityStatus,
			&i.SkillPoints,
			&i.SolarSystemID,
			&i.WalletBalance,
			&i.ID_2,
			&i.Category,
			&i.Name_2,
			&i.ID_3,
			&i.Category_2,
			&i.Name_3,
			&i.ID_4,
			&i.Category_3,
			&i.Name_4,
			&i.ID_5,
			&i.Category_4,
			&i.Name_5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacter = `-- name: UpdateCharacter :exec
UPDATE characters
SET
    alliance_id = ?,
    corporation_id = ?,
    description = ?,
    faction_id = ?,
    last_login_at = ?,
    mail_updated_at = ?,
    name = ?,
    security_status = ?,
    skill_points = ?,
    solar_system_id = ?,
    wallet_balance = ?
WHERE id = ?
`

type UpdateCharacterParams struct {
	AllianceID     sql.NullInt64
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	LastLoginAt    time.Time
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    int64
	SolarSystemID  int64
	WalletBalance  float64
	ID             int64
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacter,
		arg.AllianceID,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.LastLoginAt,
		arg.MailUpdatedAt,
		arg.Name,
		arg.SecurityStatus,
		arg.SkillPoints,
		arg.SolarSystemID,
		arg.WalletBalance,
		arg.ID,
	)
	return err
}
