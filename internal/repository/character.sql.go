// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.mail_updated_at, characters.name, characters.security_status, characters.skill_points, characters.wallet_balance, corporations.id, corporations.category, corporations.name, alliances.id, alliances.category, alliances.name, factions.id, factions.category, factions.name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
WHERE characters.id = ?
`

type GetCharacterRow struct {
	Character   Character
	EveEntity   EveEntity
	EveEntity_2 EveEntity
	EveEntity_3 EveEntity
}

func (q *Queries) GetCharacter(ctx context.Context, id int64) (GetCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, id)
	var i GetCharacterRow
	err := row.Scan(
		&i.Character.AllianceID,
		&i.Character.Birthday,
		&i.Character.CorporationID,
		&i.Character.Description,
		&i.Character.Gender,
		&i.Character.FactionID,
		&i.Character.ID,
		&i.Character.MailUpdatedAt,
		&i.Character.Name,
		&i.Character.SecurityStatus,
		&i.Character.SkillPoints,
		&i.Character.WalletBalance,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveEntity_2.ID,
		&i.EveEntity_2.Category,
		&i.EveEntity_2.Name,
		&i.EveEntity_3.ID,
		&i.EveEntity_3.Category,
		&i.EveEntity_3.Name,
	)
	return i, err
}

const getFirstCharacter = `-- name: GetFirstCharacter :one
SELECT characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.mail_updated_at, characters.name, characters.security_status, characters.skill_points, characters.wallet_balance, corporations.id, corporations.category, corporations.name, alliances.id, alliances.category, alliances.name, factions.id, factions.category, factions.name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
LIMIT 1
`

type GetFirstCharacterRow struct {
	Character   Character
	EveEntity   EveEntity
	EveEntity_2 EveEntity
	EveEntity_3 EveEntity
}

func (q *Queries) GetFirstCharacter(ctx context.Context) (GetFirstCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getFirstCharacter)
	var i GetFirstCharacterRow
	err := row.Scan(
		&i.Character.AllianceID,
		&i.Character.Birthday,
		&i.Character.CorporationID,
		&i.Character.Description,
		&i.Character.Gender,
		&i.Character.FactionID,
		&i.Character.ID,
		&i.Character.MailUpdatedAt,
		&i.Character.Name,
		&i.Character.SecurityStatus,
		&i.Character.SkillPoints,
		&i.Character.WalletBalance,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveEntity_2.ID,
		&i.EveEntity_2.Category,
		&i.EveEntity_2.Name,
		&i.EveEntity_3.ID,
		&i.EveEntity_3.Category,
		&i.EveEntity_3.Name,
	)
	return i, err
}

const listCharacterIDs = `-- name: ListCharacterIDs :many
SELECT id
FROM characters
`

func (q *Queries) ListCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.mail_updated_at, characters.name, characters.security_status, characters.skill_points, characters.wallet_balance, corporations.id, corporations.category, corporations.name, alliances.id, alliances.category, alliances.name, factions.id, factions.category, factions.name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
ORDER BY name
`

type ListCharactersRow struct {
	Character   Character
	EveEntity   EveEntity
	EveEntity_2 EveEntity
	EveEntity_3 EveEntity
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersRow
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(
			&i.Character.AllianceID,
			&i.Character.Birthday,
			&i.Character.CorporationID,
			&i.Character.Description,
			&i.Character.Gender,
			&i.Character.FactionID,
			&i.Character.ID,
			&i.Character.MailUpdatedAt,
			&i.Character.Name,
			&i.Character.SecurityStatus,
			&i.Character.SkillPoints,
			&i.Character.WalletBalance,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.EveEntity_3.ID,
			&i.EveEntity_3.Category,
			&i.EveEntity_3.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacter = `-- name: UpdateCharacter :exec
UPDATE characters
SET
    alliance_id = ?,
    corporation_id = ?,
    description = ?,
    faction_id = ?,
    mail_updated_at = ?,
    name = ?,
    security_status = ?,
    skill_points = ?,
    wallet_balance = ?
`

type UpdateCharacterParams struct {
	AllianceID     sql.NullInt64
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    sql.NullInt64
	WalletBalance  sql.NullFloat64
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacter,
		arg.AllianceID,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.MailUpdatedAt,
		arg.Name,
		arg.SecurityStatus,
		arg.SkillPoints,
		arg.WalletBalance,
	)
	return err
}

const updateOrCreateCharacter = `-- name: UpdateOrCreateCharacter :one
INSERT INTO characters (
    alliance_id,
    corporation_id,
    description,
    faction_id,
    mail_updated_at,
    name,
    security_status,
    skill_points,
    wallet_balance,
    id,
    birthday,
    gender
)
VALUES (
    ?, ?, ?, ?, ? ,?, ?, ?, ?, ?, ? ,?
)
ON CONFLICT (id) DO
UPDATE SET
    alliance_id = ?,
    corporation_id = ?,
    description = ?,
    faction_id = ?,
    mail_updated_at = ?,
    name = ?,
    security_status = ?,
    skill_points = ?,
    wallet_balance = ?
RETURNING alliance_id, birthday, corporation_id, description, gender, faction_id, id, mail_updated_at, name, security_status, skill_points, wallet_balance
`

type UpdateOrCreateCharacterParams struct {
	AllianceID     sql.NullInt64
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	MailUpdatedAt  sql.NullTime
	Name           string
	SecurityStatus float64
	SkillPoints    sql.NullInt64
	WalletBalance  sql.NullFloat64
	ID             int64
	Birthday       time.Time
	Gender         string
}

func (q *Queries) UpdateOrCreateCharacter(ctx context.Context, arg UpdateOrCreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, updateOrCreateCharacter,
		arg.AllianceID,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.MailUpdatedAt,
		arg.Name,
		arg.SecurityStatus,
		arg.SkillPoints,
		arg.WalletBalance,
		arg.ID,
		arg.Birthday,
		arg.Gender,
	)
	var i Character
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.MailUpdatedAt,
		&i.Name,
		&i.SecurityStatus,
		&i.SkillPoints,
		&i.WalletBalance,
	)
	return i, err
}
