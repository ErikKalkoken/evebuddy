// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: characters.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (
    id,
    alliance_id,
    birthday,
    corporation_id,
    description,
    faction_id,
    gender,
    last_login_at,
    name,
    race_id,
    security_status,
    ship_id,
    skill_points,
    location_id,
    wallet_balance
)
VALUES (
    ?, ?, ?, ?, ? ,?, ?, ?, ?, ?, ? ,?, ?, ?, ?
)
RETURNING alliance_id, birthday, corporation_id, description, gender, faction_id, id, last_login_at, location_id, name, race_id, security_status, ship_id, skill_points, wallet_balance
`

type CreateCharacterParams struct {
	ID             int64
	AllianceID     sql.NullInt64
	Birthday       time.Time
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	Gender         string
	LastLoginAt    time.Time
	Name           string
	RaceID         int64
	SecurityStatus float64
	ShipID         int64
	SkillPoints    int64
	LocationID     int64
	WalletBalance  float64
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.ID,
		arg.AllianceID,
		arg.Birthday,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.Gender,
		arg.LastLoginAt,
		arg.Name,
		arg.RaceID,
		arg.SecurityStatus,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
	)
	var i Character
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.LastLoginAt,
		&i.LocationID,
		&i.Name,
		&i.RaceID,
		&i.SecurityStatus,
		&i.ShipID,
		&i.SkillPoints,
		&i.WalletBalance,
	)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT
    characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.last_login_at, characters.location_id, characters.name, characters.race_id, characters.security_status, characters.ship_id, characters.skill_points, characters.wallet_balance,
    corporations.name as corporation_name,
    alliances.name as alliance_name,
    factions.name as faction_name,
    eve_races.Name as race_name,
    locations.Name as location_name,
    locations.Category as location_category,
    ships.name as ship_name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
JOIN eve_entities AS locations ON locations.id = characters.location_id
JOIN eve_races ON eve_races.id = characters.race_id
JOIN eve_entities AS ships ON ships.id = characters.ship_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
WHERE characters.id = ?
`

type GetCharacterRow struct {
	AllianceID       sql.NullInt64
	Birthday         time.Time
	CorporationID    int64
	Description      string
	Gender           string
	FactionID        sql.NullInt64
	ID               int64
	LastLoginAt      time.Time
	LocationID       int64
	Name             string
	RaceID           int64
	SecurityStatus   float64
	ShipID           int64
	SkillPoints      int64
	WalletBalance    float64
	CorporationName  string
	AllianceName     sql.NullString
	FactionName      sql.NullString
	RaceName         string
	LocationName     string
	LocationCategory string
	ShipName         string
}

func (q *Queries) GetCharacter(ctx context.Context, id int64) (GetCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, id)
	var i GetCharacterRow
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.LastLoginAt,
		&i.LocationID,
		&i.Name,
		&i.RaceID,
		&i.SecurityStatus,
		&i.ShipID,
		&i.SkillPoints,
		&i.WalletBalance,
		&i.CorporationName,
		&i.AllianceName,
		&i.FactionName,
		&i.RaceName,
		&i.LocationName,
		&i.LocationCategory,
		&i.ShipName,
	)
	return i, err
}

const listCharacterIDs = `-- name: ListCharacterIDs :many
SELECT id
FROM characters
`

func (q *Queries) ListCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT
    characters.alliance_id, characters.birthday, characters.corporation_id, characters.description, characters.gender, characters.faction_id, characters.id, characters.last_login_at, characters.location_id, characters.name, characters.race_id, characters.security_status, characters.ship_id, characters.skill_points, characters.wallet_balance,
    corporations.name as corporation_name,
    alliances.name as alliance_name,
    factions.name as faction_name,
    eve_races.Name as race_name,
    locations.Name as location_name,
    locations.Category as location_category,
    ships.name as ship_name
FROM characters
JOIN eve_entities AS corporations ON corporations.id = characters.corporation_id
JOIN eve_entities AS locations ON locations.id = characters.location_id
JOIN eve_races ON eve_races.id = characters.race_id
JOIN eve_entities AS ships ON ships.id = characters.ship_id
LEFT JOIN eve_entities AS alliances ON alliances.id = characters.alliance_id
LEFT JOIN eve_entities AS factions ON factions.id = characters.faction_id
ORDER BY characters.name
`

type ListCharactersRow struct {
	AllianceID       sql.NullInt64
	Birthday         time.Time
	CorporationID    int64
	Description      string
	Gender           string
	FactionID        sql.NullInt64
	ID               int64
	LastLoginAt      time.Time
	LocationID       int64
	Name             string
	RaceID           int64
	SecurityStatus   float64
	ShipID           int64
	SkillPoints      int64
	WalletBalance    float64
	CorporationName  string
	AllianceName     sql.NullString
	FactionName      sql.NullString
	RaceName         string
	LocationName     string
	LocationCategory string
	ShipName         string
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersRow
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(
			&i.AllianceID,
			&i.Birthday,
			&i.CorporationID,
			&i.Description,
			&i.Gender,
			&i.FactionID,
			&i.ID,
			&i.LastLoginAt,
			&i.LocationID,
			&i.Name,
			&i.RaceID,
			&i.SecurityStatus,
			&i.ShipID,
			&i.SkillPoints,
			&i.WalletBalance,
			&i.CorporationName,
			&i.AllianceName,
			&i.FactionName,
			&i.RaceName,
			&i.LocationName,
			&i.LocationCategory,
			&i.ShipName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacter = `-- name: UpdateCharacter :exec
UPDATE characters
SET
    alliance_id = ?,
    corporation_id = ?,
    description = ?,
    faction_id = ?,
    last_login_at = ?,
    name = ?,
    security_status = ?,
    ship_id = ?,
    skill_points = ?,
    location_id = ?,
    wallet_balance = ?
WHERE id = ?
`

type UpdateCharacterParams struct {
	AllianceID     sql.NullInt64
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	LastLoginAt    time.Time
	Name           string
	SecurityStatus float64
	ShipID         int64
	SkillPoints    int64
	LocationID     int64
	WalletBalance  float64
	ID             int64
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacter,
		arg.AllianceID,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.LastLoginAt,
		arg.Name,
		arg.SecurityStatus,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
		arg.ID,
	)
	return err
}

const updateOrCreateCharacter = `-- name: UpdateOrCreateCharacter :one
INSERT INTO characters (
    id,
    alliance_id,
    birthday,
    corporation_id,
    description,
    faction_id,
    gender,
    last_login_at,
    name,
    race_id,
    security_status,
    ship_id,
    skill_points,
    location_id,
    wallet_balance
)
VALUES (
    ?1, ?2, ?3, ?4, ?5 ,?6, ?7, ?8, ?9, ?10, ?11 ,?12, ?13, ?14, ?15
)
ON CONFLICT(id) DO
UPDATE SET
    alliance_id = ?2,
    corporation_id = ?4,
    description = ?5,
    faction_id = ?6,
    last_login_at = ?8,
    name = ?9,
    security_status = ?11,
    ship_id = ?12,
    skill_points = ?13,
    location_id = ?14,
    wallet_balance = ?15
WHERE id = ?1
RETURNING alliance_id, birthday, corporation_id, description, gender, faction_id, id, last_login_at, location_id, name, race_id, security_status, ship_id, skill_points, wallet_balance
`

type UpdateOrCreateCharacterParams struct {
	ID             int64
	AllianceID     sql.NullInt64
	Birthday       time.Time
	CorporationID  int64
	Description    string
	FactionID      sql.NullInt64
	Gender         string
	LastLoginAt    time.Time
	Name           string
	RaceID         int64
	SecurityStatus float64
	ShipID         int64
	SkillPoints    int64
	LocationID     int64
	WalletBalance  float64
}

func (q *Queries) UpdateOrCreateCharacter(ctx context.Context, arg UpdateOrCreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, updateOrCreateCharacter,
		arg.ID,
		arg.AllianceID,
		arg.Birthday,
		arg.CorporationID,
		arg.Description,
		arg.FactionID,
		arg.Gender,
		arg.LastLoginAt,
		arg.Name,
		arg.RaceID,
		arg.SecurityStatus,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
	)
	var i Character
	err := row.Scan(
		&i.AllianceID,
		&i.Birthday,
		&i.CorporationID,
		&i.Description,
		&i.Gender,
		&i.FactionID,
		&i.ID,
		&i.LastLoginAt,
		&i.LocationID,
		&i.Name,
		&i.RaceID,
		&i.SecurityStatus,
		&i.ShipID,
		&i.SkillPoints,
		&i.WalletBalance,
	)
	return i, err
}
