// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_assets.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const createCharacterAsset = `-- name: CreateCharacterAsset :exec
INSERT INTO character_assets (
    character_id,
    eve_type_id,
    is_blueprint_copy,
    is_singleton,
    item_id,
    location_flag,
    location_id,
    location_type,
    name,
    quantity
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterAssetParams struct {
	CharacterID     int64
	EveTypeID       int64
	IsBlueprintCopy bool
	IsSingleton     bool
	ItemID          int64
	LocationFlag    string
	LocationID      int64
	LocationType    string
	Name            string
	Quantity        int64
}

func (q *Queries) CreateCharacterAsset(ctx context.Context, arg CreateCharacterAssetParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterAsset,
		arg.CharacterID,
		arg.EveTypeID,
		arg.IsBlueprintCopy,
		arg.IsSingleton,
		arg.ItemID,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
	)
	return err
}

const deleteExcludedCharacterAssets = `-- name: DeleteExcludedCharacterAssets :exec
DELETE FROM character_assets
WHERE character_id = ?
AND item_id NOT IN (/*SLICE:item_ids*/?)
`

type DeleteExcludedCharacterAssetsParams struct {
	CharacterID int64
	ItemIds     []int64
}

func (q *Queries) DeleteExcludedCharacterAssets(ctx context.Context, arg DeleteExcludedCharacterAssetsParams) error {
	query := deleteExcludedCharacterAssets
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.ItemIds) > 0 {
		for _, v := range arg.ItemIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:item_ids*/?", strings.Repeat(",?", len(arg.ItemIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:item_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterAsset = `-- name: GetCharacterAsset :one
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
AND item_id = ?
`

type GetCharacterAssetParams struct {
	CharacterID int64
	ItemID      int64
}

type GetCharacterAssetRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) GetCharacterAsset(ctx context.Context, arg GetCharacterAssetParams) (GetCharacterAssetRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterAsset, arg.CharacterID, arg.ItemID)
	var i GetCharacterAssetRow
	err := row.Scan(
		&i.CharacterAsset.ID,
		&i.CharacterAsset.CharacterID,
		&i.CharacterAsset.EveTypeID,
		&i.CharacterAsset.IsBlueprintCopy,
		&i.CharacterAsset.IsSingleton,
		&i.CharacterAsset.ItemID,
		&i.CharacterAsset.LocationFlag,
		&i.CharacterAsset.LocationID,
		&i.CharacterAsset.LocationType,
		&i.CharacterAsset.Name,
		&i.CharacterAsset.Quantity,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
		&i.Price,
	)
	return i, err
}

const getCharacterAssetTotalValue = `-- name: GetCharacterAssetTotalValue :one
SELECT SUM(IFNULL(emp.average_price, 0) * quantity * IIF(ca.is_blueprint_copy IS TRUE, 0, 1)) as total
FROM character_assets ca
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
`

func (q *Queries) GetCharacterAssetTotalValue(ctx context.Context, characterID int64) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getCharacterAssetTotalValue, characterID)
	var total sql.NullFloat64
	err := row.Scan(&total)
	return total, err
}

const listAllCharacterAssets = `-- name: ListAllCharacterAssets :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
ORDER BY et.name, ca.location_id
`

type ListAllCharacterAssetsRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) ListAllCharacterAssets(ctx context.Context) ([]ListAllCharacterAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterAssetsRow
	for rows.Next() {
		var i ListAllCharacterAssetsRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetIDs = `-- name: ListCharacterAssetIDs :many
SELECT item_id
FROM character_assets
WHERE character_id = ?
`

func (q *Queries) ListCharacterAssetIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var item_id int64
		if err := rows.Scan(&item_id); err != nil {
			return nil, err
		}
		items = append(items, item_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetLocations = `-- name: ListCharacterAssetLocations :many
SELECT DISTINCT
    ca.character_id,
    ca.location_type,
    ca.location_id,
    lo.name as location_name,
    sys.id as system_id,
    sys.name as system_name,
    sys.security_status
FROM character_assets ca
JOIN eve_locations lo ON lo.id = ca.location_id
LEFT JOIN eve_solar_systems sys ON sys.id = lo.eve_solar_system_id
WHERE character_id = ?
AND location_flag = ?
ORDER BY location_name
`

type ListCharacterAssetLocationsParams struct {
	CharacterID  int64
	LocationFlag string
}

type ListCharacterAssetLocationsRow struct {
	CharacterID    int64
	LocationType   string
	LocationID     int64
	LocationName   string
	SystemID       sql.NullInt64
	SystemName     sql.NullString
	SecurityStatus sql.NullFloat64
}

func (q *Queries) ListCharacterAssetLocations(ctx context.Context, arg ListCharacterAssetLocationsParams) ([]ListCharacterAssetLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetLocations, arg.CharacterID, arg.LocationFlag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetLocationsRow
	for rows.Next() {
		var i ListCharacterAssetLocationsRow
		if err := rows.Scan(
			&i.CharacterID,
			&i.LocationType,
			&i.LocationID,
			&i.LocationName,
			&i.SystemID,
			&i.SystemName,
			&i.SecurityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssets = `-- name: ListCharacterAssets :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
ORDER BY et.name, ca.location_id
`

type ListCharacterAssetsRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) ListCharacterAssets(ctx context.Context, characterID int64) ([]ListCharacterAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssets, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetsRow
	for rows.Next() {
		var i ListCharacterAssetsRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetsInItemHangar = `-- name: ListCharacterAssetsInItemHangar :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
AND location_id = ?
AND location_flag = ?
AND eg.eve_category_id != ?
ORDER BY et.id
`

type ListCharacterAssetsInItemHangarParams struct {
	CharacterID   int64
	LocationID    int64
	LocationFlag  string
	EveCategoryID int64
}

type ListCharacterAssetsInItemHangarRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) ListCharacterAssetsInItemHangar(ctx context.Context, arg ListCharacterAssetsInItemHangarParams) ([]ListCharacterAssetsInItemHangarRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetsInItemHangar,
		arg.CharacterID,
		arg.LocationID,
		arg.LocationFlag,
		arg.EveCategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetsInItemHangarRow
	for rows.Next() {
		var i ListCharacterAssetsInItemHangarRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetsInLocation = `-- name: ListCharacterAssetsInLocation :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
AND location_id = ?
ORDER BY et.id
`

type ListCharacterAssetsInLocationParams struct {
	CharacterID int64
	LocationID  int64
}

type ListCharacterAssetsInLocationRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) ListCharacterAssetsInLocation(ctx context.Context, arg ListCharacterAssetsInLocationParams) ([]ListCharacterAssetsInLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetsInLocation, arg.CharacterID, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetsInLocationRow
	for rows.Next() {
		var i ListCharacterAssetsInLocationRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetsInShipHangar = `-- name: ListCharacterAssetsInShipHangar :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE character_id = ?
AND location_id = ?
AND location_flag = ?
AND eg.eve_category_id = ?
ORDER BY et.id
`

type ListCharacterAssetsInShipHangarParams struct {
	CharacterID   int64
	LocationID    int64
	LocationFlag  string
	EveCategoryID int64
}

type ListCharacterAssetsInShipHangarRow struct {
	CharacterAsset CharacterAsset
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
	Price          sql.NullFloat64
}

func (q *Queries) ListCharacterAssetsInShipHangar(ctx context.Context, arg ListCharacterAssetsInShipHangarParams) ([]ListCharacterAssetsInShipHangarRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetsInShipHangar,
		arg.CharacterID,
		arg.LocationID,
		arg.LocationFlag,
		arg.EveCategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetsInShipHangarRow
	for rows.Next() {
		var i ListCharacterAssetsInShipHangarRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterAsset = `-- name: UpdateCharacterAsset :exec
UPDATE character_assets
SET
    location_flag = ?,
    location_id = ?,
    location_type = ?,
    name = ?,
    quantity = ?
WHERE character_id = ?
AND item_id = ?
`

type UpdateCharacterAssetParams struct {
	LocationFlag string
	LocationID   int64
	LocationType string
	Name         string
	Quantity     int64
	CharacterID  int64
	ItemID       int64
}

func (q *Queries) UpdateCharacterAsset(ctx context.Context, arg UpdateCharacterAssetParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterAsset,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
		arg.CharacterID,
		arg.ItemID,
	)
	return err
}
