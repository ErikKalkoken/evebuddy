// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_assets.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const createCharacterAsset = `-- name: CreateCharacterAsset :exec
INSERT INTO character_assets (
    character_id,
    eve_type_id,
    is_blueprint_copy,
    is_singleton,
    item_id,
    location_flag,
    location_id,
    location_type,
    name,
    quantity
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterAssetParams struct {
	CharacterID     int64
	EveTypeID       int64
	IsBlueprintCopy bool
	IsSingleton     bool
	ItemID          int64
	LocationFlag    string
	LocationID      int64
	LocationType    string
	Name            string
	Quantity        int64
}

func (q *Queries) CreateCharacterAsset(ctx context.Context, arg CreateCharacterAssetParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterAsset,
		arg.CharacterID,
		arg.EveTypeID,
		arg.IsBlueprintCopy,
		arg.IsSingleton,
		arg.ItemID,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
	)
	return err
}

const deleteExcludedCharacterAssets = `-- name: DeleteExcludedCharacterAssets :exec
DELETE FROM character_assets
WHERE character_id = ?
AND item_id NOT IN (/*SLICE:item_ids*/?)
`

type DeleteExcludedCharacterAssetsParams struct {
	CharacterID int64
	ItemIds     []int64
}

func (q *Queries) DeleteExcludedCharacterAssets(ctx context.Context, arg DeleteExcludedCharacterAssetsParams) error {
	query := deleteExcludedCharacterAssets
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.ItemIds) > 0 {
		for _, v := range arg.ItemIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:item_ids*/?", strings.Repeat(",?", len(arg.ItemIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:item_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterAsset = `-- name: GetCharacterAsset :one
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.name as eve_type_name
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
WHERE character_id = ?
AND item_id = ?
`

type GetCharacterAssetParams struct {
	CharacterID int64
	ItemID      int64
}

type GetCharacterAssetRow struct {
	CharacterAsset CharacterAsset
	EveTypeName    string
}

func (q *Queries) GetCharacterAsset(ctx context.Context, arg GetCharacterAssetParams) (GetCharacterAssetRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterAsset, arg.CharacterID, arg.ItemID)
	var i GetCharacterAssetRow
	err := row.Scan(
		&i.CharacterAsset.ID,
		&i.CharacterAsset.CharacterID,
		&i.CharacterAsset.EveTypeID,
		&i.CharacterAsset.IsBlueprintCopy,
		&i.CharacterAsset.IsSingleton,
		&i.CharacterAsset.ItemID,
		&i.CharacterAsset.LocationFlag,
		&i.CharacterAsset.LocationID,
		&i.CharacterAsset.LocationType,
		&i.CharacterAsset.Name,
		&i.CharacterAsset.Quantity,
		&i.EveTypeName,
	)
	return i, err
}

const listCharacterAssetIDs = `-- name: ListCharacterAssetIDs :many
SELECT item_id
FROM character_assets
WHERE character_id = ?
`

func (q *Queries) ListCharacterAssetIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var item_id int64
		if err := rows.Scan(&item_id); err != nil {
			return nil, err
		}
		items = append(items, item_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetLocations = `-- name: ListCharacterAssetLocations :many
SELECT DISTINCT
    ca.character_id,
    ca.location_type,
    ca.location_id,
    lo.name as location_name,
    sys.id as system_id,
    sys.name as system_name
FROM character_assets ca
JOIN locations lo ON lo.id = ca.location_id
LEFT JOIN eve_solar_systems sys ON sys.id = lo.eve_solar_system_id
WHERE character_id = ?
AND location_flag = ?
ORDER BY location_name
`

type ListCharacterAssetLocationsParams struct {
	CharacterID  int64
	LocationFlag string
}

type ListCharacterAssetLocationsRow struct {
	CharacterID  int64
	LocationType string
	LocationID   int64
	LocationName string
	SystemID     sql.NullInt64
	SystemName   sql.NullString
}

func (q *Queries) ListCharacterAssetLocations(ctx context.Context, arg ListCharacterAssetLocationsParams) ([]ListCharacterAssetLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetLocations, arg.CharacterID, arg.LocationFlag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetLocationsRow
	for rows.Next() {
		var i ListCharacterAssetLocationsRow
		if err := rows.Scan(
			&i.CharacterID,
			&i.LocationType,
			&i.LocationID,
			&i.LocationName,
			&i.SystemID,
			&i.SystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterAssetsAtLocation = `-- name: ListCharacterAssetsAtLocation :many
SELECT
    ca.id, ca.character_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.name as eve_type_name
FROM character_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
WHERE character_id = ?
AND location_id = ?
`

type ListCharacterAssetsAtLocationParams struct {
	CharacterID int64
	LocationID  int64
}

type ListCharacterAssetsAtLocationRow struct {
	CharacterAsset CharacterAsset
	EveTypeName    string
}

func (q *Queries) ListCharacterAssetsAtLocation(ctx context.Context, arg ListCharacterAssetsAtLocationParams) ([]ListCharacterAssetsAtLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterAssetsAtLocation, arg.CharacterID, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterAssetsAtLocationRow
	for rows.Next() {
		var i ListCharacterAssetsAtLocationRow
		if err := rows.Scan(
			&i.CharacterAsset.ID,
			&i.CharacterAsset.CharacterID,
			&i.CharacterAsset.EveTypeID,
			&i.CharacterAsset.IsBlueprintCopy,
			&i.CharacterAsset.IsSingleton,
			&i.CharacterAsset.ItemID,
			&i.CharacterAsset.LocationFlag,
			&i.CharacterAsset.LocationID,
			&i.CharacterAsset.LocationType,
			&i.CharacterAsset.Name,
			&i.CharacterAsset.Quantity,
			&i.EveTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterAsset = `-- name: UpdateCharacterAsset :exec
UPDATE character_assets
SET
    location_flag = ?,
    location_id = ?,
    location_type = ?,
    name = ?,
    quantity = ?
WHERE character_id = ?
AND item_id = ?
`

type UpdateCharacterAssetParams struct {
	LocationFlag string
	LocationID   int64
	LocationType string
	Name         string
	Quantity     int64
	CharacterID  int64
	ItemID       int64
}

func (q *Queries) UpdateCharacterAsset(ctx context.Context, arg UpdateCharacterAssetParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterAsset,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
		arg.CharacterID,
		arg.ItemID,
	)
	return err
}
