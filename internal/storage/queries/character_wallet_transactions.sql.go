// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_wallet_transactions.sql

package queries

import (
	"context"
	"time"
)

const createCharacterWalletTransaction = `-- name: CreateCharacterWalletTransaction :exec
INSERT INTO character_wallet_transactions (
    client_id,
    date,
    eve_type_id,
    is_buy,
    is_personal,
    journal_ref_id,
    character_id,
    location_id,
    quantity,
    transaction_id,
    unit_price
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterWalletTransactionParams struct {
	ClientID      int64
	Date          time.Time
	EveTypeID     int64
	IsBuy         bool
	IsPersonal    bool
	JournalRefID  int64
	CharacterID   int64
	LocationID    int64
	Quantity      int64
	TransactionID int64
	UnitPrice     float64
}

func (q *Queries) CreateCharacterWalletTransaction(ctx context.Context, arg CreateCharacterWalletTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterWalletTransaction,
		arg.ClientID,
		arg.Date,
		arg.EveTypeID,
		arg.IsBuy,
		arg.IsPersonal,
		arg.JournalRefID,
		arg.CharacterID,
		arg.LocationID,
		arg.Quantity,
		arg.TransactionID,
		arg.UnitPrice,
	)
	return err
}

const getCharacterWalletTransaction = `-- name: GetCharacterWalletTransaction :one
SELECT character_wallet_transactions.id, character_wallet_transactions.character_id, character_wallet_transactions.client_id, character_wallet_transactions.date, character_wallet_transactions.eve_type_id, character_wallet_transactions.is_buy, character_wallet_transactions.is_personal, character_wallet_transactions.journal_ref_id, character_wallet_transactions.location_id, character_wallet_transactions.quantity, character_wallet_transactions.transaction_id, character_wallet_transactions.unit_price, eve_entities.id, eve_entities.category, eve_entities.name, eve_types.name as eve_type_name, eve_locations.name as location_name
FROM character_wallet_transactions
JOIN eve_entities ON eve_entities.id = character_wallet_transactions.client_id
JOIN eve_types ON eve_types.id = character_wallet_transactions.eve_type_id
JOIN eve_locations ON eve_locations.id = character_wallet_transactions.location_id
WHERE character_id = ? and transaction_id = ?
`

type GetCharacterWalletTransactionParams struct {
	CharacterID   int64
	TransactionID int64
}

type GetCharacterWalletTransactionRow struct {
	CharacterWalletTransaction CharacterWalletTransaction
	EveEntity                  EveEntity
	EveTypeName                string
	LocationName               string
}

func (q *Queries) GetCharacterWalletTransaction(ctx context.Context, arg GetCharacterWalletTransactionParams) (GetCharacterWalletTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterWalletTransaction, arg.CharacterID, arg.TransactionID)
	var i GetCharacterWalletTransactionRow
	err := row.Scan(
		&i.CharacterWalletTransaction.ID,
		&i.CharacterWalletTransaction.CharacterID,
		&i.CharacterWalletTransaction.ClientID,
		&i.CharacterWalletTransaction.Date,
		&i.CharacterWalletTransaction.EveTypeID,
		&i.CharacterWalletTransaction.IsBuy,
		&i.CharacterWalletTransaction.IsPersonal,
		&i.CharacterWalletTransaction.JournalRefID,
		&i.CharacterWalletTransaction.LocationID,
		&i.CharacterWalletTransaction.Quantity,
		&i.CharacterWalletTransaction.TransactionID,
		&i.CharacterWalletTransaction.UnitPrice,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveTypeName,
		&i.LocationName,
	)
	return i, err
}

const listCharacterWalletTransactionIDs = `-- name: ListCharacterWalletTransactionIDs :many
SELECT transaction_id
FROM character_wallet_transactions
WHERE character_id = ?
`

func (q *Queries) ListCharacterWalletTransactionIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletTransactionIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var transaction_id int64
		if err := rows.Scan(&transaction_id); err != nil {
			return nil, err
		}
		items = append(items, transaction_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterWalletTransactions = `-- name: ListCharacterWalletTransactions :many
SELECT character_wallet_transactions.id, character_wallet_transactions.character_id, character_wallet_transactions.client_id, character_wallet_transactions.date, character_wallet_transactions.eve_type_id, character_wallet_transactions.is_buy, character_wallet_transactions.is_personal, character_wallet_transactions.journal_ref_id, character_wallet_transactions.location_id, character_wallet_transactions.quantity, character_wallet_transactions.transaction_id, character_wallet_transactions.unit_price, eve_entities.id, eve_entities.category, eve_entities.name, eve_types.name as eve_type_name, eve_locations.name as location_name
FROM character_wallet_transactions
JOIN eve_entities ON eve_entities.id = character_wallet_transactions.client_id
JOIN eve_types ON eve_types.id = character_wallet_transactions.eve_type_id
JOIN eve_locations ON eve_locations.id = character_wallet_transactions.location_id
WHERE character_id = ?
ORDER BY date DESC
`

type ListCharacterWalletTransactionsRow struct {
	CharacterWalletTransaction CharacterWalletTransaction
	EveEntity                  EveEntity
	EveTypeName                string
	LocationName               string
}

func (q *Queries) ListCharacterWalletTransactions(ctx context.Context, characterID int64) ([]ListCharacterWalletTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletTransactions, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterWalletTransactionsRow
	for rows.Next() {
		var i ListCharacterWalletTransactionsRow
		if err := rows.Scan(
			&i.CharacterWalletTransaction.ID,
			&i.CharacterWalletTransaction.CharacterID,
			&i.CharacterWalletTransaction.ClientID,
			&i.CharacterWalletTransaction.Date,
			&i.CharacterWalletTransaction.EveTypeID,
			&i.CharacterWalletTransaction.IsBuy,
			&i.CharacterWalletTransaction.IsPersonal,
			&i.CharacterWalletTransaction.JournalRefID,
			&i.CharacterWalletTransaction.LocationID,
			&i.CharacterWalletTransaction.Quantity,
			&i.CharacterWalletTransaction.TransactionID,
			&i.CharacterWalletTransaction.UnitPrice,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveTypeName,
			&i.LocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
