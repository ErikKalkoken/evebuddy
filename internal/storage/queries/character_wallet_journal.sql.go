// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_wallet_journal.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCharacterWalletJournalEntry = `-- name: CreateCharacterWalletJournalEntry :exec
INSERT INTO character_wallet_journal_entries (
    amount,
    balance,
    context_id,
    context_id_type,
    date,
    description,
    first_party_id,
    id,
    character_id,
    reason,
    ref_type,
    second_party_id,
    tax,
    tax_receiver_id
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterWalletJournalEntryParams struct {
	Amount        float64
	Balance       float64
	ContextID     int64
	ContextIDType string
	Date          time.Time
	Description   string
	FirstPartyID  sql.NullInt64
	ID            int64
	CharacterID   int64
	Reason        string
	RefType       string
	SecondPartyID sql.NullInt64
	Tax           float64
	TaxReceiverID sql.NullInt64
}

func (q *Queries) CreateCharacterWalletJournalEntry(ctx context.Context, arg CreateCharacterWalletJournalEntryParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterWalletJournalEntry,
		arg.Amount,
		arg.Balance,
		arg.ContextID,
		arg.ContextIDType,
		arg.Date,
		arg.Description,
		arg.FirstPartyID,
		arg.ID,
		arg.CharacterID,
		arg.Reason,
		arg.RefType,
		arg.SecondPartyID,
		arg.Tax,
		arg.TaxReceiverID,
	)
	return err
}

const getCharacterWalletJournalEntry = `-- name: GetCharacterWalletJournalEntry :one
SELECT character_wallet_journal_entries.amount, character_wallet_journal_entries.balance, character_wallet_journal_entries.character_id, character_wallet_journal_entries.context_id, character_wallet_journal_entries.context_id_type, character_wallet_journal_entries.date, character_wallet_journal_entries.description, character_wallet_journal_entries.first_party_id, character_wallet_journal_entries.id, character_wallet_journal_entries.reason, character_wallet_journal_entries.ref_type, character_wallet_journal_entries.second_party_id, character_wallet_journal_entries.tax, character_wallet_journal_entries.tax_receiver_id, wallet_journal_entry_first_parties.id, wallet_journal_entry_first_parties.category, wallet_journal_entry_first_parties.name, wallet_journal_entry_second_parties.id, wallet_journal_entry_second_parties.category, wallet_journal_entry_second_parties.name, wallet_journal_entry_tax_receivers.id, wallet_journal_entry_tax_receivers.category, wallet_journal_entry_tax_receivers.name
FROM character_wallet_journal_entries
LEFT JOIN wallet_journal_entry_first_parties ON wallet_journal_entry_first_parties.id = character_wallet_journal_entries.first_party_id
LEFT JOIN wallet_journal_entry_second_parties ON wallet_journal_entry_second_parties.id = character_wallet_journal_entries.second_party_id
LEFT JOIN wallet_journal_entry_tax_receivers ON wallet_journal_entry_tax_receivers.id = character_wallet_journal_entries.tax_receiver_id
WHERE character_id = ? and character_wallet_journal_entries.id = ?
`

type GetCharacterWalletJournalEntryParams struct {
	CharacterID int64
	ID          int64
}

type GetCharacterWalletJournalEntryRow struct {
	CharacterWalletJournalEntry   CharacterWalletJournalEntry
	WalletJournalEntryFirstParty  WalletJournalEntryFirstParty
	WalletJournalEntrySecondParty WalletJournalEntrySecondParty
	WalletJournalEntryTaxReceiver WalletJournalEntryTaxReceiver
}

func (q *Queries) GetCharacterWalletJournalEntry(ctx context.Context, arg GetCharacterWalletJournalEntryParams) (GetCharacterWalletJournalEntryRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterWalletJournalEntry, arg.CharacterID, arg.ID)
	var i GetCharacterWalletJournalEntryRow
	err := row.Scan(
		&i.CharacterWalletJournalEntry.Amount,
		&i.CharacterWalletJournalEntry.Balance,
		&i.CharacterWalletJournalEntry.CharacterID,
		&i.CharacterWalletJournalEntry.ContextID,
		&i.CharacterWalletJournalEntry.ContextIDType,
		&i.CharacterWalletJournalEntry.Date,
		&i.CharacterWalletJournalEntry.Description,
		&i.CharacterWalletJournalEntry.FirstPartyID,
		&i.CharacterWalletJournalEntry.ID,
		&i.CharacterWalletJournalEntry.Reason,
		&i.CharacterWalletJournalEntry.RefType,
		&i.CharacterWalletJournalEntry.SecondPartyID,
		&i.CharacterWalletJournalEntry.Tax,
		&i.CharacterWalletJournalEntry.TaxReceiverID,
		&i.WalletJournalEntryFirstParty.ID,
		&i.WalletJournalEntryFirstParty.Category,
		&i.WalletJournalEntryFirstParty.Name,
		&i.WalletJournalEntrySecondParty.ID,
		&i.WalletJournalEntrySecondParty.Category,
		&i.WalletJournalEntrySecondParty.Name,
		&i.WalletJournalEntryTaxReceiver.ID,
		&i.WalletJournalEntryTaxReceiver.Category,
		&i.WalletJournalEntryTaxReceiver.Name,
	)
	return i, err
}

const listCharacterWalletJournalEntries = `-- name: ListCharacterWalletJournalEntries :many
SELECT DISTINCT character_wallet_journal_entries.amount, character_wallet_journal_entries.balance, character_wallet_journal_entries.character_id, character_wallet_journal_entries.context_id, character_wallet_journal_entries.context_id_type, character_wallet_journal_entries.date, character_wallet_journal_entries.description, character_wallet_journal_entries.first_party_id, character_wallet_journal_entries.id, character_wallet_journal_entries.reason, character_wallet_journal_entries.ref_type, character_wallet_journal_entries.second_party_id, character_wallet_journal_entries.tax, character_wallet_journal_entries.tax_receiver_id, wallet_journal_entry_first_parties.id, wallet_journal_entry_first_parties.category, wallet_journal_entry_first_parties.name, wallet_journal_entry_second_parties.id, wallet_journal_entry_second_parties.category, wallet_journal_entry_second_parties.name, wallet_journal_entry_tax_receivers.id, wallet_journal_entry_tax_receivers.category, wallet_journal_entry_tax_receivers.name
FROM character_wallet_journal_entries
LEFT JOIN wallet_journal_entry_first_parties ON wallet_journal_entry_first_parties.id = character_wallet_journal_entries.first_party_id
LEFT JOIN wallet_journal_entry_second_parties ON wallet_journal_entry_second_parties.id = character_wallet_journal_entries.second_party_id
LEFT JOIN wallet_journal_entry_tax_receivers ON wallet_journal_entry_tax_receivers.id = character_wallet_journal_entries.tax_receiver_id
WHERE character_id = ?
ORDER BY date DESC
`

type ListCharacterWalletJournalEntriesRow struct {
	CharacterWalletJournalEntry   CharacterWalletJournalEntry
	WalletJournalEntryFirstParty  WalletJournalEntryFirstParty
	WalletJournalEntrySecondParty WalletJournalEntrySecondParty
	WalletJournalEntryTaxReceiver WalletJournalEntryTaxReceiver
}

func (q *Queries) ListCharacterWalletJournalEntries(ctx context.Context, characterID int64) ([]ListCharacterWalletJournalEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletJournalEntries, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterWalletJournalEntriesRow
	for rows.Next() {
		var i ListCharacterWalletJournalEntriesRow
		if err := rows.Scan(
			&i.CharacterWalletJournalEntry.Amount,
			&i.CharacterWalletJournalEntry.Balance,
			&i.CharacterWalletJournalEntry.CharacterID,
			&i.CharacterWalletJournalEntry.ContextID,
			&i.CharacterWalletJournalEntry.ContextIDType,
			&i.CharacterWalletJournalEntry.Date,
			&i.CharacterWalletJournalEntry.Description,
			&i.CharacterWalletJournalEntry.FirstPartyID,
			&i.CharacterWalletJournalEntry.ID,
			&i.CharacterWalletJournalEntry.Reason,
			&i.CharacterWalletJournalEntry.RefType,
			&i.CharacterWalletJournalEntry.SecondPartyID,
			&i.CharacterWalletJournalEntry.Tax,
			&i.CharacterWalletJournalEntry.TaxReceiverID,
			&i.WalletJournalEntryFirstParty.ID,
			&i.WalletJournalEntryFirstParty.Category,
			&i.WalletJournalEntryFirstParty.Name,
			&i.WalletJournalEntrySecondParty.ID,
			&i.WalletJournalEntrySecondParty.Category,
			&i.WalletJournalEntrySecondParty.Name,
			&i.WalletJournalEntryTaxReceiver.ID,
			&i.WalletJournalEntryTaxReceiver.Category,
			&i.WalletJournalEntryTaxReceiver.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterWalletJournalEntryIDs = `-- name: ListCharacterWalletJournalEntryIDs :many
SELECT id
FROM character_wallet_journal_entries
WHERE character_id = ?
`

func (q *Queries) ListCharacterWalletJournalEntryIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletJournalEntryIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
