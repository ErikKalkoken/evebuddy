// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: wallet_transactions.sql

package queries

import (
	"context"
	"time"
)

const createWalletTransaction = `-- name: CreateWalletTransaction :exec
INSERT INTO wallet_transactions (
    client_id,
    date,
    eve_type_id,
    is_buy,
    is_personal,
    journal_ref_id,
    my_character_id,
    location_id,
    quantity,
    transaction_id,
    unit_price
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateWalletTransactionParams struct {
	ClientID      int64
	Date          time.Time
	EveTypeID     int64
	IsBuy         bool
	IsPersonal    bool
	JournalRefID  int64
	MyCharacterID int64
	LocationID    int64
	Quantity      int64
	TransactionID int64
	UnitPrice     float64
}

func (q *Queries) CreateWalletTransaction(ctx context.Context, arg CreateWalletTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createWalletTransaction,
		arg.ClientID,
		arg.Date,
		arg.EveTypeID,
		arg.IsBuy,
		arg.IsPersonal,
		arg.JournalRefID,
		arg.MyCharacterID,
		arg.LocationID,
		arg.Quantity,
		arg.TransactionID,
		arg.UnitPrice,
	)
	return err
}

const getWalletTransaction = `-- name: GetWalletTransaction :one
SELECT wallet_transactions.client_id, wallet_transactions.date, wallet_transactions.eve_type_id, wallet_transactions.is_buy, wallet_transactions.is_personal, wallet_transactions.journal_ref_id, wallet_transactions.location_id, wallet_transactions.my_character_id, wallet_transactions.quantity, wallet_transactions.transaction_id, wallet_transactions.unit_price, eve_entities.id, eve_entities.category, eve_entities.name, eve_types.name as eve_type_name, locations.name as location_name
FROM wallet_transactions
JOIN eve_entities ON eve_entities.id = wallet_transactions.client_id
JOIN eve_types ON eve_types.id = wallet_transactions.eve_type_id
JOIN locations ON locations.id = wallet_transactions.location_id
WHERE my_character_id = ? and transaction_id = ?
`

type GetWalletTransactionParams struct {
	MyCharacterID int64
	TransactionID int64
}

type GetWalletTransactionRow struct {
	WalletTransaction WalletTransaction
	EveEntity         EveEntity
	EveTypeName       string
	LocationName      string
}

func (q *Queries) GetWalletTransaction(ctx context.Context, arg GetWalletTransactionParams) (GetWalletTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletTransaction, arg.MyCharacterID, arg.TransactionID)
	var i GetWalletTransactionRow
	err := row.Scan(
		&i.WalletTransaction.ClientID,
		&i.WalletTransaction.Date,
		&i.WalletTransaction.EveTypeID,
		&i.WalletTransaction.IsBuy,
		&i.WalletTransaction.IsPersonal,
		&i.WalletTransaction.JournalRefID,
		&i.WalletTransaction.LocationID,
		&i.WalletTransaction.MyCharacterID,
		&i.WalletTransaction.Quantity,
		&i.WalletTransaction.TransactionID,
		&i.WalletTransaction.UnitPrice,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveTypeName,
		&i.LocationName,
	)
	return i, err
}

const listWalletTransactionIDs = `-- name: ListWalletTransactionIDs :many
SELECT transaction_id
FROM wallet_transactions
WHERE my_character_id = ?
`

func (q *Queries) ListWalletTransactionIDs(ctx context.Context, myCharacterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listWalletTransactionIDs, myCharacterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var transaction_id int64
		if err := rows.Scan(&transaction_id); err != nil {
			return nil, err
		}
		items = append(items, transaction_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletTransactions = `-- name: ListWalletTransactions :many
SELECT wallet_transactions.client_id, wallet_transactions.date, wallet_transactions.eve_type_id, wallet_transactions.is_buy, wallet_transactions.is_personal, wallet_transactions.journal_ref_id, wallet_transactions.location_id, wallet_transactions.my_character_id, wallet_transactions.quantity, wallet_transactions.transaction_id, wallet_transactions.unit_price, eve_entities.id, eve_entities.category, eve_entities.name, eve_types.name as eve_type_name, locations.name as location_name
FROM wallet_transactions
JOIN eve_entities ON eve_entities.id = wallet_transactions.client_id
JOIN eve_types ON eve_types.id = wallet_transactions.eve_type_id
JOIN locations ON locations.id = wallet_transactions.location_id
WHERE my_character_id = ?
ORDER BY date DESC
`

type ListWalletTransactionsRow struct {
	WalletTransaction WalletTransaction
	EveEntity         EveEntity
	EveTypeName       string
	LocationName      string
}

func (q *Queries) ListWalletTransactions(ctx context.Context, myCharacterID int64) ([]ListWalletTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listWalletTransactions, myCharacterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWalletTransactionsRow
	for rows.Next() {
		var i ListWalletTransactionsRow
		if err := rows.Scan(
			&i.WalletTransaction.ClientID,
			&i.WalletTransaction.Date,
			&i.WalletTransaction.EveTypeID,
			&i.WalletTransaction.IsBuy,
			&i.WalletTransaction.IsPersonal,
			&i.WalletTransaction.JournalRefID,
			&i.WalletTransaction.LocationID,
			&i.WalletTransaction.MyCharacterID,
			&i.WalletTransaction.Quantity,
			&i.WalletTransaction.TransactionID,
			&i.WalletTransaction.UnitPrice,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveTypeName,
			&i.LocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
