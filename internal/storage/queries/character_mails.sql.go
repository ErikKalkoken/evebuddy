// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_mails.sql

package queries

import (
	"context"
	"time"
)

const createMail = `-- name: CreateMail :one
INSERT INTO character_mails (
    body,
    character_id,
    from_id,
    is_read,
    mail_id,
    subject,
    timestamp
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, body, character_id, from_id, is_read, mail_id, subject, timestamp
`

type CreateMailParams struct {
	Body        string
	CharacterID int64
	FromID      int64
	IsRead      bool
	MailID      int64
	Subject     string
	Timestamp   time.Time
}

func (q *Queries) CreateMail(ctx context.Context, arg CreateMailParams) (CharacterMail, error) {
	row := q.db.QueryRowContext(ctx, createMail,
		arg.Body,
		arg.CharacterID,
		arg.FromID,
		arg.IsRead,
		arg.MailID,
		arg.Subject,
		arg.Timestamp,
	)
	var i CharacterMail
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.CharacterID,
		&i.FromID,
		&i.IsRead,
		&i.MailID,
		&i.Subject,
		&i.Timestamp,
	)
	return i, err
}

const createMailCharacterMailLabel = `-- name: CreateMailCharacterMailLabel :exec
INSERT INTO character_mail_mail_labels (
    character_mail_label_id,
    character_mail_id
)
VALUES (?, ?)
`

type CreateMailCharacterMailLabelParams struct {
	CharacterMailLabelID int64
	CharacterMailID      int64
}

func (q *Queries) CreateMailCharacterMailLabel(ctx context.Context, arg CreateMailCharacterMailLabelParams) error {
	_, err := q.db.ExecContext(ctx, createMailCharacterMailLabel, arg.CharacterMailLabelID, arg.CharacterMailID)
	return err
}

const createMailRecipient = `-- name: CreateMailRecipient :exec
INSERT INTO character_mails_recipients (
    mail_id,
    eve_entity_id
)
VALUES (?, ?)
`

type CreateMailRecipientParams struct {
	MailID      int64
	EveEntityID int64
}

func (q *Queries) CreateMailRecipient(ctx context.Context, arg CreateMailRecipientParams) error {
	_, err := q.db.ExecContext(ctx, createMailRecipient, arg.MailID, arg.EveEntityID)
	return err
}

const deleteMail = `-- name: DeleteMail :exec
DELETE FROM character_mails
WHERE character_mails.character_id = ?
AND character_mails.mail_id = ?
`

type DeleteMailParams struct {
	CharacterID int64
	MailID      int64
}

func (q *Queries) DeleteMail(ctx context.Context, arg DeleteMailParams) error {
	_, err := q.db.ExecContext(ctx, deleteMail, arg.CharacterID, arg.MailID)
	return err
}

const deleteMailCharacterMailLabels = `-- name: DeleteMailCharacterMailLabels :exec
DELETE FROM character_mail_mail_labels
WHERE character_mail_mail_labels.character_mail_id = ?
`

func (q *Queries) DeleteMailCharacterMailLabels(ctx context.Context, characterMailID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMailCharacterMailLabels, characterMailID)
	return err
}

const getCharacterMailLabelUnreadCounts = `-- name: GetCharacterMailLabelUnreadCounts :many
SELECT label_id, COUNT(character_mails.id) AS unread_count_2
FROM character_mail_labels
JOIN character_mail_mail_labels ON character_mail_mail_labels.character_mail_label_id = character_mail_labels.id
JOIN character_mails ON character_mails.id = character_mail_mail_labels.character_mail_id
WHERE character_mail_labels.character_id = ?
AND is_read IS FALSE
GROUP BY label_id
`

type GetCharacterMailLabelUnreadCountsRow struct {
	LabelID      int64
	UnreadCount2 int64
}

func (q *Queries) GetCharacterMailLabelUnreadCounts(ctx context.Context, characterID int64) ([]GetCharacterMailLabelUnreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterMailLabelUnreadCounts, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterMailLabelUnreadCountsRow
	for rows.Next() {
		var i GetCharacterMailLabelUnreadCountsRow
		if err := rows.Scan(&i.LabelID, &i.UnreadCount2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacterMailLabels = `-- name: GetCharacterMailLabels :many
SELECT character_mail_labels.id, character_mail_labels.character_id, character_mail_labels.color, character_mail_labels.label_id, character_mail_labels.name, character_mail_labels.unread_count
FROM character_mail_labels
JOIN character_mail_mail_labels ON character_mail_mail_labels.character_mail_label_id = character_mail_labels.id
WHERE character_mail_id = ?
`

func (q *Queries) GetCharacterMailLabels(ctx context.Context, characterMailID int64) ([]CharacterMailLabel, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterMailLabels, characterMailID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CharacterMailLabel
	for rows.Next() {
		var i CharacterMailLabel
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.Color,
			&i.LabelID,
			&i.Name,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharacterMailListUnreadCounts = `-- name: GetCharacterMailListUnreadCounts :many
SELECT eve_entities.id AS list_id, COUNT(character_mails.id) as unread_count_2
FROM character_mails
JOIN character_mails_recipients ON character_mails_recipients.mail_id = character_mails.id
JOIN eve_entities ON eve_entities.id = character_mails_recipients.eve_entity_id
WHERE character_id = ?
AND eve_entities.category = "mail_list"
AND character_mails.is_read IS FALSE
GROUP BY eve_entities.id
`

type GetCharacterMailListUnreadCountsRow struct {
	ListID       int64
	UnreadCount2 int64
}

func (q *Queries) GetCharacterMailListUnreadCounts(ctx context.Context, characterID int64) ([]GetCharacterMailListUnreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCharacterMailListUnreadCounts, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterMailListUnreadCountsRow
	for rows.Next() {
		var i GetCharacterMailListUnreadCountsRow
		if err := rows.Scan(&i.ListID, &i.UnreadCount2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMail = `-- name: GetMail :one
SELECT character_mails.id, character_mails.body, character_mails.character_id, character_mails.from_id, character_mails.is_read, character_mails.mail_id, character_mails.subject, character_mails.timestamp, eve_entities.id, eve_entities.category, eve_entities.name
FROM character_mails
JOIN eve_entities ON eve_entities.id = character_mails.from_id
WHERE character_id = ?
AND mail_id = ?
`

type GetMailParams struct {
	CharacterID int64
	MailID      int64
}

type GetMailRow struct {
	CharacterMail CharacterMail
	EveEntity     EveEntity
}

func (q *Queries) GetMail(ctx context.Context, arg GetMailParams) (GetMailRow, error) {
	row := q.db.QueryRowContext(ctx, getMail, arg.CharacterID, arg.MailID)
	var i GetMailRow
	err := row.Scan(
		&i.CharacterMail.ID,
		&i.CharacterMail.Body,
		&i.CharacterMail.CharacterID,
		&i.CharacterMail.FromID,
		&i.CharacterMail.IsRead,
		&i.CharacterMail.MailID,
		&i.CharacterMail.Subject,
		&i.CharacterMail.Timestamp,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
	)
	return i, err
}

const getMailCount = `-- name: GetMailCount :one
SELECT COUNT(*)
FROM character_mails
WHERE character_mails.character_id = ?
`

func (q *Queries) GetMailCount(ctx context.Context, characterID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMailCount, characterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMailRecipients = `-- name: GetMailRecipients :many
SELECT eve_entities.id, eve_entities.category, eve_entities.name
FROM eve_entities
JOIN character_mails_recipients ON character_mails_recipients.eve_entity_id = eve_entities.id
WHERE mail_id = ?
`

func (q *Queries) GetMailRecipients(ctx context.Context, mailID int64) ([]EveEntity, error) {
	rows, err := q.db.QueryContext(ctx, getMailRecipients, mailID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EveEntity
	for rows.Next() {
		var i EveEntity
		if err := rows.Scan(&i.ID, &i.Category, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMailUnreadCount = `-- name: GetMailUnreadCount :one
SELECT COUNT(*)
FROM character_mails
WHERE character_mails.character_id = ?
AND is_read IS FALSE
`

func (q *Queries) GetMailUnreadCount(ctx context.Context, characterID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMailUnreadCount, characterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listMailIDs = `-- name: ListMailIDs :many
SELECT mail_id
FROM character_mails
WHERE character_id = ?
`

func (q *Queries) ListMailIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listMailIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var mail_id int64
		if err := rows.Scan(&mail_id); err != nil {
			return nil, err
		}
		items = append(items, mail_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailsForLabelOrdered = `-- name: ListMailsForLabelOrdered :many
SELECT cm.subject, cm.mail_id, cm.timestamp, cm.is_read, ee.name as from_name
FROM character_mails cm
JOIN eve_entities ee ON ee.id = cm.from_id
JOIN character_mail_mail_labels cml ON cml.character_mail_id = cm.id
JOIN character_mail_labels ON character_mail_labels.id = cml.character_mail_label_id
WHERE cm.character_id = ?
AND label_id = ?
ORDER BY timestamp DESC
`

type ListMailsForLabelOrderedParams struct {
	CharacterID int64
	LabelID     int64
}

type ListMailsForLabelOrderedRow struct {
	Subject   string
	MailID    int64
	Timestamp time.Time
	IsRead    bool
	FromName  string
}

func (q *Queries) ListMailsForLabelOrdered(ctx context.Context, arg ListMailsForLabelOrderedParams) ([]ListMailsForLabelOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailsForLabelOrdered, arg.CharacterID, arg.LabelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMailsForLabelOrderedRow
	for rows.Next() {
		var i ListMailsForLabelOrderedRow
		if err := rows.Scan(
			&i.Subject,
			&i.MailID,
			&i.Timestamp,
			&i.IsRead,
			&i.FromName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailsForListOrdered = `-- name: ListMailsForListOrdered :many
SELECT cm.subject, cm.mail_id, cm.timestamp, cm.is_read, ee.name as from_name
FROM character_mails cm
JOIN eve_entities ee ON ee.id = cm.from_id
JOIN character_mails_recipients cmr ON cmr.mail_id = character_mails.id
WHERE character_id = ?
AND cmr.eve_entity_id = ?
ORDER BY timestamp DESC
`

type ListMailsForListOrderedParams struct {
	CharacterID int64
	EveEntityID int64
}

type ListMailsForListOrderedRow struct {
	Subject   string
	MailID    int64
	Timestamp time.Time
	IsRead    bool
	FromName  string
}

func (q *Queries) ListMailsForListOrdered(ctx context.Context, arg ListMailsForListOrderedParams) ([]ListMailsForListOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailsForListOrdered, arg.CharacterID, arg.EveEntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMailsForListOrderedRow
	for rows.Next() {
		var i ListMailsForListOrderedRow
		if err := rows.Scan(
			&i.Subject,
			&i.MailID,
			&i.Timestamp,
			&i.IsRead,
			&i.FromName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailsNoLabelOrdered = `-- name: ListMailsNoLabelOrdered :many
SELECT cm.subject, cm.mail_id, cm.timestamp, cm.is_read, ee.name as from_name
FROM character_mails cm
JOIN eve_entities ee ON ee.id = cm.from_id
LEFT JOIN character_mail_mail_labels cml ON cml.character_mail_id = cm.id
WHERE character_id = ?
AND cml.character_mail_id IS NULL
ORDER BY timestamp DESC
`

type ListMailsNoLabelOrderedRow struct {
	Subject   string
	MailID    int64
	Timestamp time.Time
	IsRead    bool
	FromName  string
}

func (q *Queries) ListMailsNoLabelOrdered(ctx context.Context, characterID int64) ([]ListMailsNoLabelOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailsNoLabelOrdered, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMailsNoLabelOrderedRow
	for rows.Next() {
		var i ListMailsNoLabelOrderedRow
		if err := rows.Scan(
			&i.Subject,
			&i.MailID,
			&i.Timestamp,
			&i.IsRead,
			&i.FromName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailsOrdered = `-- name: ListMailsOrdered :many
SELECT cm.subject, cm.mail_id, cm.timestamp, cm.is_read, ee.name as from_name
FROM character_mails cm
JOIN eve_entities ee ON ee.id = cm.from_id
WHERE character_id = ?
ORDER BY timestamp DESC
`

type ListMailsOrderedRow struct {
	Subject   string
	MailID    int64
	Timestamp time.Time
	IsRead    bool
	FromName  string
}

func (q *Queries) ListMailsOrdered(ctx context.Context, characterID int64) ([]ListMailsOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailsOrdered, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMailsOrderedRow
	for rows.Next() {
		var i ListMailsOrderedRow
		if err := rows.Scan(
			&i.Subject,
			&i.MailID,
			&i.Timestamp,
			&i.IsRead,
			&i.FromName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMail = `-- name: UpdateMail :exec
UPDATE character_mails
SET is_read = ?2
WHERE id = ?1
`

type UpdateMailParams struct {
	ID     int64
	IsRead bool
}

func (q *Queries) UpdateMail(ctx context.Context, arg UpdateMailParams) error {
	_, err := q.db.ExecContext(ctx, updateMail, arg.ID, arg.IsRead)
	return err
}
