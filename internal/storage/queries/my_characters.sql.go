// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: my_characters.sql

package queries

import (
	"context"
	"database/sql"
)

const createMyCharacter = `-- name: CreateMyCharacter :one
INSERT INTO my_characters (
    id,
    last_login_at,
    ship_id,
    skill_points,
    location_id,
    wallet_balance
)
VALUES (
    ?, ?, ?, ?, ? ,?
)
RETURNING id, last_login_at, location_id, ship_id, skill_points, wallet_balance
`

type CreateMyCharacterParams struct {
	ID            int64
	LastLoginAt   sql.NullTime
	ShipID        sql.NullInt64
	SkillPoints   sql.NullInt64
	LocationID    sql.NullInt64
	WalletBalance sql.NullFloat64
}

func (q *Queries) CreateMyCharacter(ctx context.Context, arg CreateMyCharacterParams) (MyCharacter, error) {
	row := q.db.QueryRowContext(ctx, createMyCharacter,
		arg.ID,
		arg.LastLoginAt,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
	)
	var i MyCharacter
	err := row.Scan(
		&i.ID,
		&i.LastLoginAt,
		&i.LocationID,
		&i.ShipID,
		&i.SkillPoints,
		&i.WalletBalance,
	)
	return i, err
}

const deleteMyCharacter = `-- name: DeleteMyCharacter :exec
DELETE FROM my_characters
WHERE id = ?
`

func (q *Queries) DeleteMyCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMyCharacter, id)
	return err
}

const getMyCharacter = `-- name: GetMyCharacter :one
SELECT
    my_characters.id, my_characters.last_login_at, my_characters.location_id, my_characters.ship_id, my_characters.skill_points, my_characters.wallet_balance,
    eve_characters.alliance_id, eve_characters.birthday, eve_characters.corporation_id, eve_characters.description, eve_characters.gender, eve_characters.faction_id, eve_characters.id, eve_characters.name, eve_characters.race_id, eve_characters.security_status, eve_characters.title,
    corporations.id, corporations.category, corporations.name,
    eve_races.id, eve_races.description, eve_races.name,
    eve_character_alliances.id, eve_character_alliances.category, eve_character_alliances.name,
    eve_character_factions.id, eve_character_factions.category, eve_character_factions.name,
    location_id,
    ship_id
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
JOIN eve_races ON eve_races.id = eve_characters.race_id
LEFT JOIN eve_character_alliances ON eve_character_alliances.id = eve_characters.alliance_id
LEFT JOIN eve_character_factions ON eve_character_factions.id = eve_characters.faction_id
WHERE my_characters.id = ?
`

type GetMyCharacterRow struct {
	MyCharacter          MyCharacter
	EveCharacter         EveCharacter
	EveEntity            EveEntity
	EveRace              EveRace
	EveCharacterAlliance EveCharacterAlliance
	EveCharacterFaction  EveCharacterFaction
	LocationID           sql.NullInt64
	ShipID               sql.NullInt64
}

func (q *Queries) GetMyCharacter(ctx context.Context, id int64) (GetMyCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getMyCharacter, id)
	var i GetMyCharacterRow
	err := row.Scan(
		&i.MyCharacter.ID,
		&i.MyCharacter.LastLoginAt,
		&i.MyCharacter.LocationID,
		&i.MyCharacter.ShipID,
		&i.MyCharacter.SkillPoints,
		&i.MyCharacter.WalletBalance,
		&i.EveCharacter.AllianceID,
		&i.EveCharacter.Birthday,
		&i.EveCharacter.CorporationID,
		&i.EveCharacter.Description,
		&i.EveCharacter.Gender,
		&i.EveCharacter.FactionID,
		&i.EveCharacter.ID,
		&i.EveCharacter.Name,
		&i.EveCharacter.RaceID,
		&i.EveCharacter.SecurityStatus,
		&i.EveCharacter.Title,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveRace.ID,
		&i.EveRace.Description,
		&i.EveRace.Name,
		&i.EveCharacterAlliance.ID,
		&i.EveCharacterAlliance.Category,
		&i.EveCharacterAlliance.Name,
		&i.EveCharacterFaction.ID,
		&i.EveCharacterFaction.Category,
		&i.EveCharacterFaction.Name,
		&i.LocationID,
		&i.ShipID,
	)
	return i, err
}

const listMyCharacterIDs = `-- name: ListMyCharacterIDs :many
SELECT id
FROM my_characters
`

func (q *Queries) ListMyCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCharacters = `-- name: ListMyCharacters :many
SELECT DISTINCT
    my_characters.id, my_characters.last_login_at, my_characters.location_id, my_characters.ship_id, my_characters.skill_points, my_characters.wallet_balance,
    eve_characters.alliance_id, eve_characters.birthday, eve_characters.corporation_id, eve_characters.description, eve_characters.gender, eve_characters.faction_id, eve_characters.id, eve_characters.name, eve_characters.race_id, eve_characters.security_status, eve_characters.title,
    corporations.id, corporations.category, corporations.name,
    eve_races.id, eve_races.description, eve_races.name,
    eve_character_alliances.id, eve_character_alliances.category, eve_character_alliances.name,
    eve_character_factions.id, eve_character_factions.category, eve_character_factions.name,
    location_id,
    ship_id
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
JOIN eve_races ON eve_races.id = eve_characters.race_id
LEFT JOIN eve_character_alliances ON eve_character_alliances.id = eve_characters.alliance_id
LEFT JOIN eve_character_factions ON eve_character_factions.id = eve_characters.faction_id
ORDER BY eve_characters.name
`

type ListMyCharactersRow struct {
	MyCharacter          MyCharacter
	EveCharacter         EveCharacter
	EveEntity            EveEntity
	EveRace              EveRace
	EveCharacterAlliance EveCharacterAlliance
	EveCharacterFaction  EveCharacterFaction
	LocationID           sql.NullInt64
	ShipID               sql.NullInt64
}

func (q *Queries) ListMyCharacters(ctx context.Context) ([]ListMyCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMyCharactersRow
	for rows.Next() {
		var i ListMyCharactersRow
		if err := rows.Scan(
			&i.MyCharacter.ID,
			&i.MyCharacter.LastLoginAt,
			&i.MyCharacter.LocationID,
			&i.MyCharacter.ShipID,
			&i.MyCharacter.SkillPoints,
			&i.MyCharacter.WalletBalance,
			&i.EveCharacter.AllianceID,
			&i.EveCharacter.Birthday,
			&i.EveCharacter.CorporationID,
			&i.EveCharacter.Description,
			&i.EveCharacter.Gender,
			&i.EveCharacter.FactionID,
			&i.EveCharacter.ID,
			&i.EveCharacter.Name,
			&i.EveCharacter.RaceID,
			&i.EveCharacter.SecurityStatus,
			&i.EveCharacter.Title,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveRace.ID,
			&i.EveRace.Description,
			&i.EveRace.Name,
			&i.EveCharacterAlliance.ID,
			&i.EveCharacterAlliance.Category,
			&i.EveCharacterAlliance.Name,
			&i.EveCharacterFaction.ID,
			&i.EveCharacterFaction.Category,
			&i.EveCharacterFaction.Name,
			&i.LocationID,
			&i.ShipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCharactersShort = `-- name: ListMyCharactersShort :many
SELECT DISTINCT eve_characters.id, eve_characters.name, corporations.name
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
ORDER BY eve_characters.name
`

type ListMyCharactersShortRow struct {
	ID     int64
	Name   string
	Name_2 string
}

func (q *Queries) ListMyCharactersShort(ctx context.Context) ([]ListMyCharactersShortRow, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharactersShort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMyCharactersShortRow
	for rows.Next() {
		var i ListMyCharactersShortRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Name_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMyCharacter = `-- name: UpdateMyCharacter :exec
UPDATE my_characters
SET
    last_login_at = ?,
    ship_id = ?,
    skill_points = ?,
    location_id = ?,
    wallet_balance = ?
WHERE id = ?
`

type UpdateMyCharacterParams struct {
	LastLoginAt   sql.NullTime
	ShipID        sql.NullInt64
	SkillPoints   sql.NullInt64
	LocationID    sql.NullInt64
	WalletBalance sql.NullFloat64
	ID            int64
}

func (q *Queries) UpdateMyCharacter(ctx context.Context, arg UpdateMyCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacter,
		arg.LastLoginAt,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
		arg.ID,
	)
	return err
}

const updateOrCreateMyCharacter = `-- name: UpdateOrCreateMyCharacter :exec
INSERT INTO my_characters (
    id,
    last_login_at,
    ship_id,
    skill_points,
    location_id,
    wallet_balance
)
VALUES (
    ?1, ?2, ?3, ?4, ?5 ,?6
)
ON CONFLICT(id) DO
UPDATE SET
    last_login_at = ?2,
    ship_id = ?3,
    skill_points = ?4,
    location_id = ?5,
    wallet_balance = ?6
WHERE id = ?1
`

type UpdateOrCreateMyCharacterParams struct {
	ID            int64
	LastLoginAt   sql.NullTime
	ShipID        sql.NullInt64
	SkillPoints   sql.NullInt64
	LocationID    sql.NullInt64
	WalletBalance sql.NullFloat64
}

func (q *Queries) UpdateOrCreateMyCharacter(ctx context.Context, arg UpdateOrCreateMyCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateMyCharacter,
		arg.ID,
		arg.LastLoginAt,
		arg.ShipID,
		arg.SkillPoints,
		arg.LocationID,
		arg.WalletBalance,
	)
	return err
}
