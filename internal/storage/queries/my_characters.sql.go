// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: my_characters.sql

package queries

import (
	"context"
	"database/sql"
)

const deleteMyCharacter = `-- name: DeleteMyCharacter :exec
DELETE FROM my_characters
WHERE id = ?
`

func (q *Queries) DeleteMyCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMyCharacter, id)
	return err
}

const getMyCharacter = `-- name: GetMyCharacter :one
SELECT
    my_characters.id, my_characters.home_id, my_characters.last_login_at, my_characters.location_id, my_characters.ship_id, my_characters.total_sp, my_characters.unallocated_sp, my_characters.wallet_balance,
    eve_characters.alliance_id, eve_characters.birthday, eve_characters.corporation_id, eve_characters.description, eve_characters.gender, eve_characters.faction_id, eve_characters.id, eve_characters.name, eve_characters.race_id, eve_characters.security_status, eve_characters.title,
    corporations.id, corporations.category, corporations.name,
    eve_races.id, eve_races.description, eve_races.name,
    eve_character_alliances.id, eve_character_alliances.category, eve_character_alliances.name,
    eve_character_factions.id, eve_character_factions.category, eve_character_factions.name,
    home_id,
    location_id,
    ship_id
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
JOIN eve_races ON eve_races.id = eve_characters.race_id
LEFT JOIN eve_character_alliances ON eve_character_alliances.id = eve_characters.alliance_id
LEFT JOIN eve_character_factions ON eve_character_factions.id = eve_characters.faction_id
WHERE my_characters.id = ?
`

type GetMyCharacterRow struct {
	MyCharacter          MyCharacter
	EveCharacter         EveCharacter
	EveEntity            EveEntity
	EveRace              EveRace
	EveCharacterAlliance EveCharacterAlliance
	EveCharacterFaction  EveCharacterFaction
	HomeID               sql.NullInt64
	LocationID           sql.NullInt64
	ShipID               sql.NullInt64
}

func (q *Queries) GetMyCharacter(ctx context.Context, id int64) (GetMyCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getMyCharacter, id)
	var i GetMyCharacterRow
	err := row.Scan(
		&i.MyCharacter.ID,
		&i.MyCharacter.HomeID,
		&i.MyCharacter.LastLoginAt,
		&i.MyCharacter.LocationID,
		&i.MyCharacter.ShipID,
		&i.MyCharacter.TotalSp,
		&i.MyCharacter.UnallocatedSp,
		&i.MyCharacter.WalletBalance,
		&i.EveCharacter.AllianceID,
		&i.EveCharacter.Birthday,
		&i.EveCharacter.CorporationID,
		&i.EveCharacter.Description,
		&i.EveCharacter.Gender,
		&i.EveCharacter.FactionID,
		&i.EveCharacter.ID,
		&i.EveCharacter.Name,
		&i.EveCharacter.RaceID,
		&i.EveCharacter.SecurityStatus,
		&i.EveCharacter.Title,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveRace.ID,
		&i.EveRace.Description,
		&i.EveRace.Name,
		&i.EveCharacterAlliance.ID,
		&i.EveCharacterAlliance.Category,
		&i.EveCharacterAlliance.Name,
		&i.EveCharacterFaction.ID,
		&i.EveCharacterFaction.Category,
		&i.EveCharacterFaction.Name,
		&i.HomeID,
		&i.LocationID,
		&i.ShipID,
	)
	return i, err
}

const listMyCharacterIDs = `-- name: ListMyCharacterIDs :many
SELECT id
FROM my_characters
`

func (q *Queries) ListMyCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCharacters = `-- name: ListMyCharacters :many
SELECT DISTINCT
    my_characters.id, my_characters.home_id, my_characters.last_login_at, my_characters.location_id, my_characters.ship_id, my_characters.total_sp, my_characters.unallocated_sp, my_characters.wallet_balance,
    eve_characters.alliance_id, eve_characters.birthday, eve_characters.corporation_id, eve_characters.description, eve_characters.gender, eve_characters.faction_id, eve_characters.id, eve_characters.name, eve_characters.race_id, eve_characters.security_status, eve_characters.title,
    corporations.id, corporations.category, corporations.name,
    eve_races.id, eve_races.description, eve_races.name,
    eve_character_alliances.id, eve_character_alliances.category, eve_character_alliances.name,
    eve_character_factions.id, eve_character_factions.category, eve_character_factions.name,
    home_id,
    location_id,
    ship_id
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
JOIN eve_races ON eve_races.id = eve_characters.race_id
LEFT JOIN eve_character_alliances ON eve_character_alliances.id = eve_characters.alliance_id
LEFT JOIN eve_character_factions ON eve_character_factions.id = eve_characters.faction_id
ORDER BY eve_characters.name
`

type ListMyCharactersRow struct {
	MyCharacter          MyCharacter
	EveCharacter         EveCharacter
	EveEntity            EveEntity
	EveRace              EveRace
	EveCharacterAlliance EveCharacterAlliance
	EveCharacterFaction  EveCharacterFaction
	HomeID               sql.NullInt64
	LocationID           sql.NullInt64
	ShipID               sql.NullInt64
}

func (q *Queries) ListMyCharacters(ctx context.Context) ([]ListMyCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMyCharactersRow
	for rows.Next() {
		var i ListMyCharactersRow
		if err := rows.Scan(
			&i.MyCharacter.ID,
			&i.MyCharacter.HomeID,
			&i.MyCharacter.LastLoginAt,
			&i.MyCharacter.LocationID,
			&i.MyCharacter.ShipID,
			&i.MyCharacter.TotalSp,
			&i.MyCharacter.UnallocatedSp,
			&i.MyCharacter.WalletBalance,
			&i.EveCharacter.AllianceID,
			&i.EveCharacter.Birthday,
			&i.EveCharacter.CorporationID,
			&i.EveCharacter.Description,
			&i.EveCharacter.Gender,
			&i.EveCharacter.FactionID,
			&i.EveCharacter.ID,
			&i.EveCharacter.Name,
			&i.EveCharacter.RaceID,
			&i.EveCharacter.SecurityStatus,
			&i.EveCharacter.Title,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveRace.ID,
			&i.EveRace.Description,
			&i.EveRace.Name,
			&i.EveCharacterAlliance.ID,
			&i.EveCharacterAlliance.Category,
			&i.EveCharacterAlliance.Name,
			&i.EveCharacterFaction.ID,
			&i.EveCharacterFaction.Category,
			&i.EveCharacterFaction.Name,
			&i.HomeID,
			&i.LocationID,
			&i.ShipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCharactersShort = `-- name: ListMyCharactersShort :many
SELECT DISTINCT eve_characters.id, eve_characters.name, corporations.name
FROM my_characters
JOIN eve_characters ON eve_characters.id = my_characters.id
JOIN eve_entities AS corporations ON corporations.id = eve_characters.corporation_id
ORDER BY eve_characters.name
`

type ListMyCharactersShortRow struct {
	ID     int64
	Name   string
	Name_2 string
}

func (q *Queries) ListMyCharactersShort(ctx context.Context) ([]ListMyCharactersShortRow, error) {
	rows, err := q.db.QueryContext(ctx, listMyCharactersShort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMyCharactersShortRow
	for rows.Next() {
		var i ListMyCharactersShortRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Name_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMyCharacterHomeId = `-- name: UpdateMyCharacterHomeId :exec
UPDATE my_characters
SET
    home_id = ?
WHERE id = ?
`

type UpdateMyCharacterHomeIdParams struct {
	HomeID sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateMyCharacterHomeId(ctx context.Context, arg UpdateMyCharacterHomeIdParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterHomeId, arg.HomeID, arg.ID)
	return err
}

const updateMyCharacterLastLoginAt = `-- name: UpdateMyCharacterLastLoginAt :exec
UPDATE my_characters
SET
    last_login_at = ?
WHERE id = ?
`

type UpdateMyCharacterLastLoginAtParams struct {
	LastLoginAt sql.NullTime
	ID          int64
}

func (q *Queries) UpdateMyCharacterLastLoginAt(ctx context.Context, arg UpdateMyCharacterLastLoginAtParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterLastLoginAt, arg.LastLoginAt, arg.ID)
	return err
}

const updateMyCharacterLocationID = `-- name: UpdateMyCharacterLocationID :exec
UPDATE my_characters
SET
    location_id = ?
WHERE id = ?
`

type UpdateMyCharacterLocationIDParams struct {
	LocationID sql.NullInt64
	ID         int64
}

func (q *Queries) UpdateMyCharacterLocationID(ctx context.Context, arg UpdateMyCharacterLocationIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterLocationID, arg.LocationID, arg.ID)
	return err
}

const updateMyCharacterSP = `-- name: UpdateMyCharacterSP :exec
UPDATE my_characters
SET
    total_sp = ?,
    unallocated_sp = ?
WHERE id = ?
`

type UpdateMyCharacterSPParams struct {
	TotalSp       sql.NullInt64
	UnallocatedSp sql.NullInt64
	ID            int64
}

func (q *Queries) UpdateMyCharacterSP(ctx context.Context, arg UpdateMyCharacterSPParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterSP, arg.TotalSp, arg.UnallocatedSp, arg.ID)
	return err
}

const updateMyCharacterShipID = `-- name: UpdateMyCharacterShipID :exec
UPDATE my_characters
SET
    ship_id = ?
WHERE id = ?
`

type UpdateMyCharacterShipIDParams struct {
	ShipID sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateMyCharacterShipID(ctx context.Context, arg UpdateMyCharacterShipIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterShipID, arg.ShipID, arg.ID)
	return err
}

const updateMyCharacterWalletBalance = `-- name: UpdateMyCharacterWalletBalance :exec
UPDATE my_characters
SET
    wallet_balance = ?
WHERE id = ?
`

type UpdateMyCharacterWalletBalanceParams struct {
	WalletBalance sql.NullFloat64
	ID            int64
}

func (q *Queries) UpdateMyCharacterWalletBalance(ctx context.Context, arg UpdateMyCharacterWalletBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateMyCharacterWalletBalance, arg.WalletBalance, arg.ID)
	return err
}

const updateOrCreateMyCharacter = `-- name: UpdateOrCreateMyCharacter :exec
INSERT INTO my_characters (
    id,
    home_id,
    last_login_at,
    location_id,
    ship_id,
    total_sp,
    unallocated_sp,
    wallet_balance
)
VALUES (
    ?1, ?2, ?3, ?4, ?5 ,?6, ?7, ?8
)
ON CONFLICT(id) DO
UPDATE SET
    home_id = ?2,
    last_login_at = ?3,
    location_id = ?4,
    ship_id = ?5,
    total_sp = ?6,
    unallocated_sp = ?7,
    wallet_balance = ?8
WHERE id = ?1
`

type UpdateOrCreateMyCharacterParams struct {
	ID            int64
	HomeID        sql.NullInt64
	LastLoginAt   sql.NullTime
	LocationID    sql.NullInt64
	ShipID        sql.NullInt64
	TotalSp       sql.NullInt64
	UnallocatedSp sql.NullInt64
	WalletBalance sql.NullFloat64
}

func (q *Queries) UpdateOrCreateMyCharacter(ctx context.Context, arg UpdateOrCreateMyCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateMyCharacter,
		arg.ID,
		arg.HomeID,
		arg.LastLoginAt,
		arg.LocationID,
		arg.ShipID,
		arg.TotalSp,
		arg.UnallocatedSp,
		arg.WalletBalance,
	)
	return err
}
