// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: corporations.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const createCorporation = `-- name: CreateCorporation :exec
INSERT INTO
    corporations (id)
VALUES
    (?)
`

func (q *Queries) CreateCorporation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, createCorporation, id)
	return err
}

const deleteCorporation = `-- name: DeleteCorporation :exec
DELETE FROM corporations
WHERE
    id = ?
`

func (q *Queries) DeleteCorporation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCorporation, id)
	return err
}

const getCorporation = `-- name: GetCorporation :one
SELECT
    ec.id, ec.alliance_id, ec.ceo_id, ec.creator_id, ec.date_founded, ec.description, ec.faction_id, ec.home_station_id, ec.member_count, ec.name, ec.shares, ec.tax_rate, ec.ticker, ec.url, ec.war_eligible,
    eec.name as ceo_name,
    eec.category as ceo_category,
    eer.name as creator_name,
    eer.category as creator_category,
    eea.name as alliance_name,
    eea.category as alliance_category,
    eef.name as faction_name,
    eef.category as faction_category,
    eeh.name as station_name,
    eeh.category as station_category
FROM
    corporations co
    JOIN eve_corporations ec ON ec.id = co.id
    LEFT JOIN eve_entities AS eec ON eec.id = ec.ceo_id
    LEFT JOIN eve_entities AS eer ON eer.id = ec.creator_id
    LEFT JOIN eve_entities as eea ON eea.id = ec.alliance_id
    LEFT JOIN eve_entities as eef ON eef.id = ec.faction_id
    LEFT JOIN eve_entities as eeh ON eeh.id = ec.home_station_id
WHERE
    co.id = ?
`

type GetCorporationRow struct {
	EveCorporation   EveCorporation
	CeoName          sql.NullString
	CeoCategory      sql.NullString
	CreatorName      sql.NullString
	CreatorCategory  sql.NullString
	AllianceName     sql.NullString
	AllianceCategory sql.NullString
	FactionName      sql.NullString
	FactionCategory  sql.NullString
	StationName      sql.NullString
	StationCategory  sql.NullString
}

func (q *Queries) GetCorporation(ctx context.Context, id int64) (GetCorporationRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporation, id)
	var i GetCorporationRow
	err := row.Scan(
		&i.EveCorporation.ID,
		&i.EveCorporation.AllianceID,
		&i.EveCorporation.CeoID,
		&i.EveCorporation.CreatorID,
		&i.EveCorporation.DateFounded,
		&i.EveCorporation.Description,
		&i.EveCorporation.FactionID,
		&i.EveCorporation.HomeStationID,
		&i.EveCorporation.MemberCount,
		&i.EveCorporation.Name,
		&i.EveCorporation.Shares,
		&i.EveCorporation.TaxRate,
		&i.EveCorporation.Ticker,
		&i.EveCorporation.Url,
		&i.EveCorporation.WarEligible,
		&i.CeoName,
		&i.CeoCategory,
		&i.CreatorName,
		&i.CreatorCategory,
		&i.AllianceName,
		&i.AllianceCategory,
		&i.FactionName,
		&i.FactionCategory,
		&i.StationName,
		&i.StationCategory,
	)
	return i, err
}

const listCorporationIDs = `-- name: ListCorporationIDs :many
SELECT
    id
FROM
    corporations
`

func (q *Queries) ListCorporationIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationsShort = `-- name: ListCorporationsShort :many
SELECT
    cp.id,
    ec.name
FROM
    corporations cp
    JOIN eve_corporations ec ON ec.id = cp.id
ORDER BY
    ec.name
`

type ListCorporationsShortRow struct {
	ID   int64
	Name string
}

func (q *Queries) ListCorporationsShort(ctx context.Context) ([]ListCorporationsShortRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationsShort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationsShortRow
	for rows.Next() {
		var i ListCorporationsShortRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrphanedCorporationIDs = `-- name: ListOrphanedCorporationIDs :many
SELECT
    id
FROM
    corporations
WHERE
    id NOT IN (
        SELECT
            ec.corporation_id
        FROM
            characters ch
            JOIN eve_characters ec ON ec.id = ch.id
    )
`

func (q *Queries) ListOrphanedCorporationIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listOrphanedCorporationIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrivilegedCorporationsShort = `-- name: ListPrivilegedCorporationsShort :many
SELECT
    cp.id,
    ec.name
FROM
    corporations cp
    JOIN eve_corporations ec ON ec.id = cp.id
WHERE
    cp.id IN (
        SELECT DISTINCT
            cp.id
        FROM
            corporations cp
            JOIN eve_characters ec ON ec.corporation_id == cp.id
            JOIN character_roles cr ON cr.character_id = ec.id
        WHERE
            cr.name IN (/*SLICE:required_roles*/?)
    )
ORDER BY
    ec.name
`

type ListPrivilegedCorporationsShortRow struct {
	ID   int64
	Name string
}

func (q *Queries) ListPrivilegedCorporationsShort(ctx context.Context, requiredRoles []string) ([]ListPrivilegedCorporationsShortRow, error) {
	query := listPrivilegedCorporationsShort
	var queryParams []interface{}
	if len(requiredRoles) > 0 {
		for _, v := range requiredRoles {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:required_roles*/?", strings.Repeat(",?", len(requiredRoles))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:required_roles*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPrivilegedCorporationsShortRow
	for rows.Next() {
		var i ListPrivilegedCorporationsShortRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
