// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: character_skills.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const deleteCharacterSkills = `-- name: DeleteCharacterSkills :exec
DELETE FROM character_skills
WHERE
    character_id = ?
    AND eve_type_id IN (/*SLICE:eve_type_ids*/?)
`

type DeleteCharacterSkillsParams struct {
	CharacterID int64
	EveTypeIds  []int64
}

func (q *Queries) DeleteCharacterSkills(ctx context.Context, arg DeleteCharacterSkillsParams) error {
	query := deleteCharacterSkills
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.EveTypeIds) > 0 {
		for _, v := range arg.EveTypeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:eve_type_ids*/?", strings.Repeat(",?", len(arg.EveTypeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:eve_type_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterSkill = `-- name: GetCharacterSkill :one
SELECT
    cs.id, cs.active_skill_level, cs.character_id, cs.eve_type_id, cs.skill_points_in_skill, cs.trained_skill_level,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    character_skills cs
    JOIN eve_types et ON et.id = cs.eve_type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    character_id = ?
    AND eve_type_id = ?
`

type GetCharacterSkillParams struct {
	CharacterID int64
	EveTypeID   int64
}

type GetCharacterSkillRow struct {
	CharacterSkill CharacterSkill
	EveType        EveType
	EveGroup       EveGroup
	EveCategory    EveCategory
}

func (q *Queries) GetCharacterSkill(ctx context.Context, arg GetCharacterSkillParams) (GetCharacterSkillRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterSkill, arg.CharacterID, arg.EveTypeID)
	var i GetCharacterSkillRow
	err := row.Scan(
		&i.CharacterSkill.ID,
		&i.CharacterSkill.ActiveSkillLevel,
		&i.CharacterSkill.CharacterID,
		&i.CharacterSkill.EveTypeID,
		&i.CharacterSkill.SkillPointsInSkill,
		&i.CharacterSkill.TrainedSkillLevel,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
	)
	return i, err
}

const listCharacterShipSkills = `-- name: ListCharacterShipSkills :many
SELECT
    rank,
    ship_type_id,
    skill_type_id,
    skt.name as skill_name,
    skill_level,
    cs.active_skill_level,
    cs.trained_skill_level
FROM
    eve_ship_skills ess
    JOIN eve_types as sht ON sht.id = ess.ship_type_id
    JOIN eve_types as skt ON skt.id = ess.skill_type_id
    LEFT JOIN character_skills cs ON cs.eve_type_id = skill_type_id
    AND cs.character_id = ?
WHERE
    ship_type_id = ?
ORDER BY
    RANK
`

type ListCharacterShipSkillsParams struct {
	CharacterID int64
	ShipTypeID  int64
}

type ListCharacterShipSkillsRow struct {
	Rank              int64
	ShipTypeID        int64
	SkillTypeID       int64
	SkillName         string
	SkillLevel        int64
	ActiveSkillLevel  sql.NullInt64
	TrainedSkillLevel sql.NullInt64
}

func (q *Queries) ListCharacterShipSkills(ctx context.Context, arg ListCharacterShipSkillsParams) ([]ListCharacterShipSkillsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterShipSkills, arg.CharacterID, arg.ShipTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterShipSkillsRow
	for rows.Next() {
		var i ListCharacterShipSkillsRow
		if err := rows.Scan(
			&i.Rank,
			&i.ShipTypeID,
			&i.SkillTypeID,
			&i.SkillName,
			&i.SkillLevel,
			&i.ActiveSkillLevel,
			&i.TrainedSkillLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterShipsAbilities = `-- name: ListCharacterShipsAbilities :many
SELECT DISTINCT
    ss2.ship_type_id as type_id,
    et.name as type_name,
    eg.id as group_id,
    eg.name as group_name,
    (
        SELECT
            COUNT(*) - SUM(
                IFNULL(cs.active_skill_level, 0) >= ss.skill_level
            ) == 0
        FROM
            eve_ship_skills ss
            LEFT JOIN character_skills cs ON cs.eve_type_id = ss.skill_type_id
            AND cs.character_id = ?
        WHERE
            ss.ship_type_id = ss2.ship_type_id
    ) as can_fly
FROM
    eve_ship_skills ss2
    JOIN eve_types et ON et.ID = ss2.ship_type_id
    JOIN eve_groups eg ON eg.ID = et.eve_group_id
WHERE
    et.name LIKE ?
ORDER BY
    et.name
`

type ListCharacterShipsAbilitiesParams struct {
	CharacterID int64
	Name        string
}

type ListCharacterShipsAbilitiesRow struct {
	TypeID    int64
	TypeName  string
	GroupID   int64
	GroupName string
	CanFly    bool
}

func (q *Queries) ListCharacterShipsAbilities(ctx context.Context, arg ListCharacterShipsAbilitiesParams) ([]ListCharacterShipsAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterShipsAbilities, arg.CharacterID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterShipsAbilitiesRow
	for rows.Next() {
		var i ListCharacterShipsAbilitiesRow
		if err := rows.Scan(
			&i.TypeID,
			&i.TypeName,
			&i.GroupID,
			&i.GroupName,
			&i.CanFly,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterSkillGroupsProgress = `-- name: ListCharacterSkillGroupsProgress :many
SELECT
    eve_groups.id as eve_group_id,
    eve_groups.name as eve_group_name,
    COUNT(eve_types.id) as total,
    SUM(character_skills.trained_skill_level / 5.0) AS trained
FROM
    eve_types
    JOIN eve_groups ON eve_groups.id = eve_types.eve_group_id
    AND eve_groups.is_published IS TRUE
    LEFT JOIN character_skills ON character_skills.eve_type_id = eve_types.id
    AND character_skills.character_id = ?
WHERE
    eve_groups.eve_category_id = ?
    AND eve_types.is_published IS TRUE
GROUP BY
    eve_groups.name
ORDER BY
    eve_groups.name
`

type ListCharacterSkillGroupsProgressParams struct {
	CharacterID   int64
	EveCategoryID int64
}

type ListCharacterSkillGroupsProgressRow struct {
	EveGroupID   int64
	EveGroupName string
	Total        int64
	Trained      sql.NullFloat64
}

func (q *Queries) ListCharacterSkillGroupsProgress(ctx context.Context, arg ListCharacterSkillGroupsProgressParams) ([]ListCharacterSkillGroupsProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterSkillGroupsProgress, arg.CharacterID, arg.EveCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterSkillGroupsProgressRow
	for rows.Next() {
		var i ListCharacterSkillGroupsProgressRow
		if err := rows.Scan(
			&i.EveGroupID,
			&i.EveGroupName,
			&i.Total,
			&i.Trained,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterSkillIDs = `-- name: ListCharacterSkillIDs :many
SELECT
    eve_type_id
FROM
    character_skills
WHERE
    character_id = ?
`

func (q *Queries) ListCharacterSkillIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterSkillIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var eve_type_id int64
		if err := rows.Scan(&eve_type_id); err != nil {
			return nil, err
		}
		items = append(items, eve_type_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterSkillProgress = `-- name: ListCharacterSkillProgress :many
SELECT
    eve_types.id,
    eve_types.name,
    eve_types.description,
    character_skills.active_skill_level,
    character_skills.trained_skill_level
FROM
    eve_types
    LEFT JOIN character_skills ON character_skills.eve_type_id = eve_types.id
    AND character_skills.character_id = ?
WHERE
    eve_types.eve_group_id = ?
    AND eve_types.is_published IS TRUE
ORDER BY
    eve_types.name
`

type ListCharacterSkillProgressParams struct {
	CharacterID int64
	EveGroupID  int64
}

type ListCharacterSkillProgressRow struct {
	ID                int64
	Name              string
	Description       string
	ActiveSkillLevel  sql.NullInt64
	TrainedSkillLevel sql.NullInt64
}

func (q *Queries) ListCharacterSkillProgress(ctx context.Context, arg ListCharacterSkillProgressParams) ([]ListCharacterSkillProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterSkillProgress, arg.CharacterID, arg.EveGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterSkillProgressRow
	for rows.Next() {
		var i ListCharacterSkillProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ActiveSkillLevel,
			&i.TrainedSkillLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersActiveSkillLevels = `-- name: ListCharactersActiveSkillLevels :many
SELECT
    c.id as character_id,
    CAST(IFNULL(cs.active_skill_level, 0) as INT) as level
FROM
    characters c
    LEFT JOIN character_skills cs ON cs.character_id = c.id
    AND cs.eve_type_id = ?
`

type ListCharactersActiveSkillLevelsRow struct {
	CharacterID int64
	Level       int64
}

func (q *Queries) ListCharactersActiveSkillLevels(ctx context.Context, eveTypeID int64) ([]ListCharactersActiveSkillLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersActiveSkillLevels, eveTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersActiveSkillLevelsRow
	for rows.Next() {
		var i ListCharactersActiveSkillLevelsRow
		if err := rows.Scan(&i.CharacterID, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrCreateCharacterSkill = `-- name: UpdateOrCreateCharacterSkill :exec
INSERT INTO
    character_skills (
        character_id,
        eve_type_id,
        active_skill_level,
        skill_points_in_skill,
        trained_skill_level
    )
VALUES
    (?1, ?2, ?3, ?4, ?5)
ON CONFLICT (character_id, eve_type_id) DO UPDATE
SET
    active_skill_level = ?3,
    skill_points_in_skill = ?4,
    trained_skill_level = ?5
`

type UpdateOrCreateCharacterSkillParams struct {
	CharacterID        int64
	EveTypeID          int64
	ActiveSkillLevel   int64
	SkillPointsInSkill int64
	TrainedSkillLevel  int64
}

func (q *Queries) UpdateOrCreateCharacterSkill(ctx context.Context, arg UpdateOrCreateCharacterSkillParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateCharacterSkill,
		arg.CharacterID,
		arg.EveTypeID,
		arg.ActiveSkillLevel,
		arg.SkillPointsInSkill,
		arg.TrainedSkillLevel,
	)
	return err
}
