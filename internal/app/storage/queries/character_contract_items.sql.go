// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: character_contract_items.sql

package queries

import (
	"context"
)

const createCharacterContractItem = `-- name: CreateCharacterContractItem :exec
INSERT INTO
    character_contract_items (
        contract_id,
        is_included,
        is_singleton,
        quantity,
        raw_quantity,
        record_id,
        type_id
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
`

type CreateCharacterContractItemParams struct {
	ContractID  int64
	IsIncluded  bool
	IsSingleton bool
	Quantity    int64
	RawQuantity int64
	RecordID    int64
	TypeID      int64
}

func (q *Queries) CreateCharacterContractItem(ctx context.Context, arg CreateCharacterContractItemParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterContractItem,
		arg.ContractID,
		arg.IsIncluded,
		arg.IsSingleton,
		arg.Quantity,
		arg.RawQuantity,
		arg.RecordID,
		arg.TypeID,
	)
	return err
}

const getCharacterContractItem = `-- name: GetCharacterContractItem :one
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    character_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
    AND record_id = ?
`

type GetCharacterContractItemParams struct {
	ContractID int64
	RecordID   int64
}

type GetCharacterContractItemRow struct {
	CharacterContractItem CharacterContractItem
	EveType               EveType
	EveGroup              EveGroup
	EveCategory           EveCategory
}

func (q *Queries) GetCharacterContractItem(ctx context.Context, arg GetCharacterContractItemParams) (GetCharacterContractItemRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterContractItem, arg.ContractID, arg.RecordID)
	var i GetCharacterContractItemRow
	err := row.Scan(
		&i.CharacterContractItem.ID,
		&i.CharacterContractItem.ContractID,
		&i.CharacterContractItem.IsIncluded,
		&i.CharacterContractItem.IsSingleton,
		&i.CharacterContractItem.Quantity,
		&i.CharacterContractItem.RawQuantity,
		&i.CharacterContractItem.RecordID,
		&i.CharacterContractItem.TypeID,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
	)
	return i, err
}

const listCharacterContractItems = `-- name: ListCharacterContractItems :many
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    character_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
`

type ListCharacterContractItemsRow struct {
	CharacterContractItem CharacterContractItem
	EveType               EveType
	EveGroup              EveGroup
	EveCategory           EveCategory
}

func (q *Queries) ListCharacterContractItems(ctx context.Context, contractID int64) ([]ListCharacterContractItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractItems, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterContractItemsRow
	for rows.Next() {
		var i ListCharacterContractItemsRow
		if err := rows.Scan(
			&i.CharacterContractItem.ID,
			&i.CharacterContractItem.ContractID,
			&i.CharacterContractItem.IsIncluded,
			&i.CharacterContractItem.IsSingleton,
			&i.CharacterContractItem.Quantity,
			&i.CharacterContractItem.RawQuantity,
			&i.CharacterContractItem.RecordID,
			&i.CharacterContractItem.TypeID,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
