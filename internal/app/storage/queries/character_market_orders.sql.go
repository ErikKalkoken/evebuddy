// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: character_market_orders.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const deleteCharacterMarketOrder = `-- name: DeleteCharacterMarketOrder :exec
DELETE FROM character_market_orders
WHERE
    character_id = ?
    AND order_id IN (/*SLICE:order_ids*/?)
`

type DeleteCharacterMarketOrderParams struct {
	CharacterID int64
	OrderIds    []int64
}

func (q *Queries) DeleteCharacterMarketOrder(ctx context.Context, arg DeleteCharacterMarketOrderParams) error {
	query := deleteCharacterMarketOrder
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.OrderIds) > 0 {
		for _, v := range arg.OrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:order_ids*/?", strings.Repeat(",?", len(arg.OrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:order_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterMarketOrder = `-- name: GetCharacterMarketOrder :one
SELECT
    cmo.id, cmo.character_id, cmo.duration, cmo.escrow, cmo.is_buy_order, cmo.is_corporation, cmo.issued, cmo.location_id, cmo.min_volume, cmo.order_id, cmo.owner_id, cmo.price, cmo."range", cmo.region_id, cmo.state, cmo.type_id, cmo.volume_remains, cmo.volume_total,
    ee.id, ee.category, ee.name,
    et.name AS type_name,
    el.name AS location_name,
    er.name AS region_name,
    els.security_status as location_security
FROM
    character_market_orders cmo
    JOIN eve_entities ee ON ee.id = cmo.owner_id
    JOIN eve_locations el ON el.id = cmo.location_id
    JOIN eve_regions er ON er.id = cmo.region_id
    JOIN eve_types et ON et.id = cmo.type_id
    LEFT JOIN eve_solar_systems els ON els.id = el.eve_solar_system_id
WHERE
    character_id = ?
    AND order_id = ?
`

type GetCharacterMarketOrderParams struct {
	CharacterID int64
	OrderID     int64
}

type GetCharacterMarketOrderRow struct {
	CharacterMarketOrder CharacterMarketOrder
	EveEntity            EveEntity
	TypeName             string
	LocationName         string
	RegionName           string
	LocationSecurity     sql.NullFloat64
}

func (q *Queries) GetCharacterMarketOrder(ctx context.Context, arg GetCharacterMarketOrderParams) (GetCharacterMarketOrderRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterMarketOrder, arg.CharacterID, arg.OrderID)
	var i GetCharacterMarketOrderRow
	err := row.Scan(
		&i.CharacterMarketOrder.ID,
		&i.CharacterMarketOrder.CharacterID,
		&i.CharacterMarketOrder.Duration,
		&i.CharacterMarketOrder.Escrow,
		&i.CharacterMarketOrder.IsBuyOrder,
		&i.CharacterMarketOrder.IsCorporation,
		&i.CharacterMarketOrder.Issued,
		&i.CharacterMarketOrder.LocationID,
		&i.CharacterMarketOrder.MinVolume,
		&i.CharacterMarketOrder.OrderID,
		&i.CharacterMarketOrder.OwnerID,
		&i.CharacterMarketOrder.Price,
		&i.CharacterMarketOrder.Range,
		&i.CharacterMarketOrder.RegionID,
		&i.CharacterMarketOrder.State,
		&i.CharacterMarketOrder.TypeID,
		&i.CharacterMarketOrder.VolumeRemains,
		&i.CharacterMarketOrder.VolumeTotal,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.TypeName,
		&i.LocationName,
		&i.RegionName,
		&i.LocationSecurity,
	)
	return i, err
}

const listAllCharacterMarketOrders = `-- name: ListAllCharacterMarketOrders :many
SELECT
    cmo.id, cmo.character_id, cmo.duration, cmo.escrow, cmo.is_buy_order, cmo.is_corporation, cmo.issued, cmo.location_id, cmo.min_volume, cmo.order_id, cmo.owner_id, cmo.price, cmo."range", cmo.region_id, cmo.state, cmo.type_id, cmo.volume_remains, cmo.volume_total,
    ee.id, ee.category, ee.name,
    et.name AS type_name,
    el.name AS location_name,
    er.name AS region_name,
    els.security_status as location_security
FROM
    character_market_orders cmo
    JOIN eve_entities ee ON ee.id = cmo.owner_id
    JOIN eve_locations el ON el.id = cmo.location_id
    JOIN eve_regions er ON er.id = cmo.region_id
    JOIN eve_types et ON et.id = cmo.type_id
    LEFT JOIN eve_solar_systems els ON els.id = el.eve_solar_system_id
WHERE
    cmo.is_buy_order = ?
`

type ListAllCharacterMarketOrdersRow struct {
	CharacterMarketOrder CharacterMarketOrder
	EveEntity            EveEntity
	TypeName             string
	LocationName         string
	RegionName           string
	LocationSecurity     sql.NullFloat64
}

func (q *Queries) ListAllCharacterMarketOrders(ctx context.Context, isBuyOrder bool) ([]ListAllCharacterMarketOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterMarketOrders, isBuyOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterMarketOrdersRow
	for rows.Next() {
		var i ListAllCharacterMarketOrdersRow
		if err := rows.Scan(
			&i.CharacterMarketOrder.ID,
			&i.CharacterMarketOrder.CharacterID,
			&i.CharacterMarketOrder.Duration,
			&i.CharacterMarketOrder.Escrow,
			&i.CharacterMarketOrder.IsBuyOrder,
			&i.CharacterMarketOrder.IsCorporation,
			&i.CharacterMarketOrder.Issued,
			&i.CharacterMarketOrder.LocationID,
			&i.CharacterMarketOrder.MinVolume,
			&i.CharacterMarketOrder.OrderID,
			&i.CharacterMarketOrder.OwnerID,
			&i.CharacterMarketOrder.Price,
			&i.CharacterMarketOrder.Range,
			&i.CharacterMarketOrder.RegionID,
			&i.CharacterMarketOrder.State,
			&i.CharacterMarketOrder.TypeID,
			&i.CharacterMarketOrder.VolumeRemains,
			&i.CharacterMarketOrder.VolumeTotal,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.TypeName,
			&i.LocationName,
			&i.RegionName,
			&i.LocationSecurity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterMarketOrderIDs = `-- name: ListCharacterMarketOrderIDs :many
SELECT
    order_id
FROM
    character_market_orders
WHERE
    character_id = ?
`

func (q *Queries) ListCharacterMarketOrderIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterMarketOrderIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var order_id int64
		if err := rows.Scan(&order_id); err != nil {
			return nil, err
		}
		items = append(items, order_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterMarketOrders = `-- name: ListCharacterMarketOrders :many
SELECT
    cmo.id, cmo.character_id, cmo.duration, cmo.escrow, cmo.is_buy_order, cmo.is_corporation, cmo.issued, cmo.location_id, cmo.min_volume, cmo.order_id, cmo.owner_id, cmo.price, cmo."range", cmo.region_id, cmo.state, cmo.type_id, cmo.volume_remains, cmo.volume_total,
    ee.id, ee.category, ee.name,
    et.name AS type_name,
    el.name AS location_name,
    er.name AS region_name,
    els.security_status as location_security
FROM
    character_market_orders cmo
    JOIN eve_entities ee ON ee.id = cmo.owner_id
    JOIN eve_locations el ON el.id = cmo.location_id
    JOIN eve_regions er ON er.id = cmo.region_id
    JOIN eve_types et ON et.id = cmo.type_id
    LEFT JOIN eve_solar_systems els ON els.id = el.eve_solar_system_id
WHERE
    character_id = ?
`

type ListCharacterMarketOrdersRow struct {
	CharacterMarketOrder CharacterMarketOrder
	EveEntity            EveEntity
	TypeName             string
	LocationName         string
	RegionName           string
	LocationSecurity     sql.NullFloat64
}

func (q *Queries) ListCharacterMarketOrders(ctx context.Context, characterID int64) ([]ListCharacterMarketOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterMarketOrders, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterMarketOrdersRow
	for rows.Next() {
		var i ListCharacterMarketOrdersRow
		if err := rows.Scan(
			&i.CharacterMarketOrder.ID,
			&i.CharacterMarketOrder.CharacterID,
			&i.CharacterMarketOrder.Duration,
			&i.CharacterMarketOrder.Escrow,
			&i.CharacterMarketOrder.IsBuyOrder,
			&i.CharacterMarketOrder.IsCorporation,
			&i.CharacterMarketOrder.Issued,
			&i.CharacterMarketOrder.LocationID,
			&i.CharacterMarketOrder.MinVolume,
			&i.CharacterMarketOrder.OrderID,
			&i.CharacterMarketOrder.OwnerID,
			&i.CharacterMarketOrder.Price,
			&i.CharacterMarketOrder.Range,
			&i.CharacterMarketOrder.RegionID,
			&i.CharacterMarketOrder.State,
			&i.CharacterMarketOrder.TypeID,
			&i.CharacterMarketOrder.VolumeRemains,
			&i.CharacterMarketOrder.VolumeTotal,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.TypeName,
			&i.LocationName,
			&i.RegionName,
			&i.LocationSecurity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterMarketOrderState = `-- name: UpdateCharacterMarketOrderState :exec
UPDATE character_market_orders
SET
    state = ?
WHERE
    character_id = ?
    AND order_id IN (/*SLICE:order_ids*/?)
`

type UpdateCharacterMarketOrderStateParams struct {
	State       string
	CharacterID int64
	OrderIds    []int64
}

func (q *Queries) UpdateCharacterMarketOrderState(ctx context.Context, arg UpdateCharacterMarketOrderStateParams) error {
	query := updateCharacterMarketOrderState
	var queryParams []interface{}
	queryParams = append(queryParams, arg.State)
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.OrderIds) > 0 {
		for _, v := range arg.OrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:order_ids*/?", strings.Repeat(",?", len(arg.OrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:order_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateOrCreateCharacterMarketOrder = `-- name: UpdateOrCreateCharacterMarketOrder :exec
INSERT INTO
    character_market_orders (
        character_id,
        duration,
        escrow,
        is_buy_order,
        is_corporation,
        issued,
        location_id,
        min_volume,
        order_id,
        owner_id,
        price,
        range,
        region_id,
        state,
        type_id,
        volume_remains,
        volume_total
    )
VALUES
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17
    )
ON CONFLICT (character_id, order_id) DO UPDATE
SET
    escrow = ?3,
    price = ?11,
    state = ?14,
    volume_remains = ?16
`

type UpdateOrCreateCharacterMarketOrderParams struct {
	CharacterID   int64
	Duration      int64
	Escrow        sql.NullFloat64
	IsBuyOrder    bool
	IsCorporation bool
	Issued        time.Time
	LocationID    int64
	MinVolume     sql.NullInt64
	OrderID       int64
	OwnerID       int64
	Price         float64
	Range         string
	RegionID      int64
	State         string
	TypeID        int64
	VolumeRemains int64
	VolumeTotal   int64
}

func (q *Queries) UpdateOrCreateCharacterMarketOrder(ctx context.Context, arg UpdateOrCreateCharacterMarketOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateCharacterMarketOrder,
		arg.CharacterID,
		arg.Duration,
		arg.Escrow,
		arg.IsBuyOrder,
		arg.IsCorporation,
		arg.Issued,
		arg.LocationID,
		arg.MinVolume,
		arg.OrderID,
		arg.OwnerID,
		arg.Price,
		arg.Range,
		arg.RegionID,
		arg.State,
		arg.TypeID,
		arg.VolumeRemains,
		arg.VolumeTotal,
	)
	return err
}
