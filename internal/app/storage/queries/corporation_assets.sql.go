// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: corporation_assets.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const calculateCorporationAssetTotalValue = `-- name: CalculateCorporationAssetTotalValue :one
SELECT SUM(IFNULL(emp.average_price, 0) * quantity * IIF(ca.is_blueprint_copy IS TRUE, 0, 1)) as total
FROM corporation_assets ca
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id
WHERE corporation_id = ?
`

func (q *Queries) CalculateCorporationAssetTotalValue(ctx context.Context, corporationID int64) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, calculateCorporationAssetTotalValue, corporationID)
	var total sql.NullFloat64
	err := row.Scan(&total)
	return total, err
}

const createCorporationAsset = `-- name: CreateCorporationAsset :exec
INSERT INTO corporation_assets (
    corporation_id,
    eve_type_id,
    is_blueprint_copy,
    is_singleton,
    item_id,
    location_flag,
    location_id,
    location_type,
    name,
    quantity
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCorporationAssetParams struct {
	CorporationID   int64
	EveTypeID       int64
	IsBlueprintCopy bool
	IsSingleton     bool
	ItemID          int64
	LocationFlag    string
	LocationID      int64
	LocationType    string
	Name            string
	Quantity        int64
}

func (q *Queries) CreateCorporationAsset(ctx context.Context, arg CreateCorporationAssetParams) error {
	_, err := q.db.ExecContext(ctx, createCorporationAsset,
		arg.CorporationID,
		arg.EveTypeID,
		arg.IsBlueprintCopy,
		arg.IsSingleton,
		arg.ItemID,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
	)
	return err
}

const deleteCorporationAssets = `-- name: DeleteCorporationAssets :exec
DELETE FROM corporation_assets
WHERE corporation_id = ?
AND item_id IN (/*SLICE:item_ids*/?)
`

type DeleteCorporationAssetsParams struct {
	CorporationID int64
	ItemIds       []int64
}

func (q *Queries) DeleteCorporationAssets(ctx context.Context, arg DeleteCorporationAssetsParams) error {
	query := deleteCorporationAssets
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CorporationID)
	if len(arg.ItemIds) > 0 {
		for _, v := range arg.ItemIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:item_ids*/?", strings.Repeat(",?", len(arg.ItemIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:item_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCorporationAsset = `-- name: GetCorporationAsset :one
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
WHERE corporation_id = ?
AND item_id = ?
`

type GetCorporationAssetParams struct {
	CorporationID int64
	ItemID        int64
}

type GetCorporationAssetRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) GetCorporationAsset(ctx context.Context, arg GetCorporationAssetParams) (GetCorporationAssetRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporationAsset, arg.CorporationID, arg.ItemID)
	var i GetCorporationAssetRow
	err := row.Scan(
		&i.CorporationAsset.ID,
		&i.CorporationAsset.CorporationID,
		&i.CorporationAsset.EveTypeID,
		&i.CorporationAsset.IsBlueprintCopy,
		&i.CorporationAsset.IsSingleton,
		&i.CorporationAsset.ItemID,
		&i.CorporationAsset.LocationFlag,
		&i.CorporationAsset.LocationID,
		&i.CorporationAsset.LocationType,
		&i.CorporationAsset.Name,
		&i.CorporationAsset.Quantity,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
		&i.Price,
	)
	return i, err
}

const listAllCorporationAssets = `-- name: ListAllCorporationAssets :many
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
`

type ListAllCorporationAssetsRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) ListAllCorporationAssets(ctx context.Context) ([]ListAllCorporationAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCorporationAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCorporationAssetsRow
	for rows.Next() {
		var i ListAllCorporationAssetsRow
		if err := rows.Scan(
			&i.CorporationAsset.ID,
			&i.CorporationAsset.CorporationID,
			&i.CorporationAsset.EveTypeID,
			&i.CorporationAsset.IsBlueprintCopy,
			&i.CorporationAsset.IsSingleton,
			&i.CorporationAsset.ItemID,
			&i.CorporationAsset.LocationFlag,
			&i.CorporationAsset.LocationID,
			&i.CorporationAsset.LocationType,
			&i.CorporationAsset.Name,
			&i.CorporationAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationAssetIDs = `-- name: ListCorporationAssetIDs :many
SELECT item_id
FROM corporation_assets
WHERE corporation_id = ?
`

func (q *Queries) ListCorporationAssetIDs(ctx context.Context, corporationID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationAssetIDs, corporationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var item_id int64
		if err := rows.Scan(&item_id); err != nil {
			return nil, err
		}
		items = append(items, item_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationAssets = `-- name: ListCorporationAssets :many
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
WHERE corporation_id = ?
`

type ListCorporationAssetsRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) ListCorporationAssets(ctx context.Context, corporationID int64) ([]ListCorporationAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationAssets, corporationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationAssetsRow
	for rows.Next() {
		var i ListCorporationAssetsRow
		if err := rows.Scan(
			&i.CorporationAsset.ID,
			&i.CorporationAsset.CorporationID,
			&i.CorporationAsset.EveTypeID,
			&i.CorporationAsset.IsBlueprintCopy,
			&i.CorporationAsset.IsSingleton,
			&i.CorporationAsset.ItemID,
			&i.CorporationAsset.LocationFlag,
			&i.CorporationAsset.LocationID,
			&i.CorporationAsset.LocationType,
			&i.CorporationAsset.Name,
			&i.CorporationAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationAssetsInItemHangar = `-- name: ListCorporationAssetsInItemHangar :many
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
WHERE corporation_id = ?
AND location_id = ?
AND location_flag = ?
AND eg.eve_category_id != ?
ORDER BY et.id, ca.name
`

type ListCorporationAssetsInItemHangarParams struct {
	CorporationID int64
	LocationID    int64
	LocationFlag  string
	EveCategoryID int64
}

type ListCorporationAssetsInItemHangarRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) ListCorporationAssetsInItemHangar(ctx context.Context, arg ListCorporationAssetsInItemHangarParams) ([]ListCorporationAssetsInItemHangarRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationAssetsInItemHangar,
		arg.CorporationID,
		arg.LocationID,
		arg.LocationFlag,
		arg.EveCategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationAssetsInItemHangarRow
	for rows.Next() {
		var i ListCorporationAssetsInItemHangarRow
		if err := rows.Scan(
			&i.CorporationAsset.ID,
			&i.CorporationAsset.CorporationID,
			&i.CorporationAsset.EveTypeID,
			&i.CorporationAsset.IsBlueprintCopy,
			&i.CorporationAsset.IsSingleton,
			&i.CorporationAsset.ItemID,
			&i.CorporationAsset.LocationFlag,
			&i.CorporationAsset.LocationID,
			&i.CorporationAsset.LocationType,
			&i.CorporationAsset.Name,
			&i.CorporationAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationAssetsInLocation = `-- name: ListCorporationAssetsInLocation :many
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
WHERE corporation_id = ?
AND location_id = ?
ORDER BY et.id, ca.name
`

type ListCorporationAssetsInLocationParams struct {
	CorporationID int64
	LocationID    int64
}

type ListCorporationAssetsInLocationRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) ListCorporationAssetsInLocation(ctx context.Context, arg ListCorporationAssetsInLocationParams) ([]ListCorporationAssetsInLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationAssetsInLocation, arg.CorporationID, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationAssetsInLocationRow
	for rows.Next() {
		var i ListCorporationAssetsInLocationRow
		if err := rows.Scan(
			&i.CorporationAsset.ID,
			&i.CorporationAsset.CorporationID,
			&i.CorporationAsset.EveTypeID,
			&i.CorporationAsset.IsBlueprintCopy,
			&i.CorporationAsset.IsSingleton,
			&i.CorporationAsset.ItemID,
			&i.CorporationAsset.LocationFlag,
			&i.CorporationAsset.LocationID,
			&i.CorporationAsset.LocationType,
			&i.CorporationAsset.Name,
			&i.CorporationAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationAssetsInShipHangar = `-- name: ListCorporationAssetsInShipHangar :many
SELECT
    ca.id, ca.corporation_id, ca.eve_type_id, ca.is_blueprint_copy, ca.is_singleton, ca.item_id, ca.location_flag, ca.location_id, ca.location_type, ca.name, ca.quantity,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published,
    average_price as price
FROM corporation_assets ca
JOIN eve_types et ON et.id = ca.eve_type_id
JOIN eve_groups eg ON eg.id = et.eve_group_id
JOIN eve_categories ec ON ec.id = eg.eve_category_id
LEFT JOIN eve_market_prices emp ON emp.type_id = ca.eve_type_id AND ca.is_blueprint_copy IS FALSE
WHERE corporation_id = ?
AND location_id = ?
AND location_flag = ?
AND eg.eve_category_id = ?
ORDER BY et.id, ca.name
`

type ListCorporationAssetsInShipHangarParams struct {
	CorporationID int64
	LocationID    int64
	LocationFlag  string
	EveCategoryID int64
}

type ListCorporationAssetsInShipHangarRow struct {
	CorporationAsset CorporationAsset
	EveType          EveType
	EveGroup         EveGroup
	EveCategory      EveCategory
	Price            sql.NullFloat64
}

func (q *Queries) ListCorporationAssetsInShipHangar(ctx context.Context, arg ListCorporationAssetsInShipHangarParams) ([]ListCorporationAssetsInShipHangarRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationAssetsInShipHangar,
		arg.CorporationID,
		arg.LocationID,
		arg.LocationFlag,
		arg.EveCategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationAssetsInShipHangarRow
	for rows.Next() {
		var i ListCorporationAssetsInShipHangarRow
		if err := rows.Scan(
			&i.CorporationAsset.ID,
			&i.CorporationAsset.CorporationID,
			&i.CorporationAsset.EveTypeID,
			&i.CorporationAsset.IsBlueprintCopy,
			&i.CorporationAsset.IsSingleton,
			&i.CorporationAsset.ItemID,
			&i.CorporationAsset.LocationFlag,
			&i.CorporationAsset.LocationID,
			&i.CorporationAsset.LocationType,
			&i.CorporationAsset.Name,
			&i.CorporationAsset.Quantity,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCorporationAsset = `-- name: UpdateCorporationAsset :exec
UPDATE corporation_assets
SET
    location_flag = ?,
    location_id = ?,
    location_type = ?,
    name = ?,
    quantity = ?
WHERE corporation_id = ?
AND item_id = ?
`

type UpdateCorporationAssetParams struct {
	LocationFlag  string
	LocationID    int64
	LocationType  string
	Name          string
	Quantity      int64
	CorporationID int64
	ItemID        int64
}

func (q *Queries) UpdateCorporationAsset(ctx context.Context, arg UpdateCorporationAssetParams) error {
	_, err := q.db.ExecContext(ctx, updateCorporationAsset,
		arg.LocationFlag,
		arg.LocationID,
		arg.LocationType,
		arg.Name,
		arg.Quantity,
		arg.CorporationID,
		arg.ItemID,
	)
	return err
}
