// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: characters.sql

package queries

import (
	"context"
	"database/sql"
)

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT
    cc.id, cc.asset_value, cc.home_id, cc.last_login_at, cc.location_id, cc.ship_id, cc.total_sp, cc.unallocated_sp, cc.wallet_balance,
    ec.alliance_id, ec.birthday, ec.corporation_id, ec.description, ec.gender, ec.faction_id, ec.id, ec.name, ec.race_id, ec.security_status, ec.title,
    eec.id, eec.category, eec.name,
    er.id, er.description, er.name,
    eea.name as alliance_name,
    eea.category as alliance_category,
    eef.name as faction_name,
    eef.category as faction_category,
    home_id,
    location_id,
    ship_id
FROM characters cc
JOIN eve_characters ec ON ec.id = cc.id
JOIN eve_entities eec ON eec.id = ec.corporation_id
JOIN eve_races er ON er .id = ec.race_id
LEFT JOIN eve_entities eea ON eea.id = ec.alliance_id
LEFT JOIN eve_entities eef ON eef.id = ec.faction_id
WHERE cc.id = ?
`

type GetCharacterRow struct {
	Character        Character
	EveCharacter     EveCharacter
	EveEntity        EveEntity
	EveRace          EveRace
	AllianceName     sql.NullString
	AllianceCategory sql.NullString
	FactionName      sql.NullString
	FactionCategory  sql.NullString
	HomeID           sql.NullInt64
	LocationID       sql.NullInt64
	ShipID           sql.NullInt64
}

func (q *Queries) GetCharacter(ctx context.Context, id int64) (GetCharacterRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, id)
	var i GetCharacterRow
	err := row.Scan(
		&i.Character.ID,
		&i.Character.AssetValue,
		&i.Character.HomeID,
		&i.Character.LastLoginAt,
		&i.Character.LocationID,
		&i.Character.ShipID,
		&i.Character.TotalSp,
		&i.Character.UnallocatedSp,
		&i.Character.WalletBalance,
		&i.EveCharacter.AllianceID,
		&i.EveCharacter.Birthday,
		&i.EveCharacter.CorporationID,
		&i.EveCharacter.Description,
		&i.EveCharacter.Gender,
		&i.EveCharacter.FactionID,
		&i.EveCharacter.ID,
		&i.EveCharacter.Name,
		&i.EveCharacter.RaceID,
		&i.EveCharacter.SecurityStatus,
		&i.EveCharacter.Title,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveRace.ID,
		&i.EveRace.Description,
		&i.EveRace.Name,
		&i.AllianceName,
		&i.AllianceCategory,
		&i.FactionName,
		&i.FactionCategory,
		&i.HomeID,
		&i.LocationID,
		&i.ShipID,
	)
	return i, err
}

const getCharacterAssetValue = `-- name: GetCharacterAssetValue :one
SELECT asset_value
FROM characters
WHERE id = ?
`

func (q *Queries) GetCharacterAssetValue(ctx context.Context, id int64) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getCharacterAssetValue, id)
	var asset_value sql.NullFloat64
	err := row.Scan(&asset_value)
	return asset_value, err
}

const listCharacterIDs = `-- name: ListCharacterIDs :many
SELECT id
FROM characters
`

func (q *Queries) ListCharacterIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT DISTINCT
    cc.id, cc.asset_value, cc.home_id, cc.last_login_at, cc.location_id, cc.ship_id, cc.total_sp, cc.unallocated_sp, cc.wallet_balance,
    ec.alliance_id, ec.birthday, ec.corporation_id, ec.description, ec.gender, ec.faction_id, ec.id, ec.name, ec.race_id, ec.security_status, ec.title,
    eec.id, eec.category, eec.name,
    er.id, er.description, er.name,
    eea.name as alliance_name,
    eea.category as alliance_category,
    eef.name as faction_name,
    eef.category as faction_category,
    home_id,
    location_id,
    ship_id
FROM characters cc
JOIN eve_characters ec ON ec.id = cc.id
JOIN eve_entities eec ON eec.id = ec.corporation_id
JOIN eve_races er ON er.id = ec.race_id
LEFT JOIN eve_entities eea ON eea.id = ec.alliance_id
LEFT JOIN eve_entities eef ON eef.id = ec.faction_id
ORDER BY ec.name
`

type ListCharactersRow struct {
	Character        Character
	EveCharacter     EveCharacter
	EveEntity        EveEntity
	EveRace          EveRace
	AllianceName     sql.NullString
	AllianceCategory sql.NullString
	FactionName      sql.NullString
	FactionCategory  sql.NullString
	HomeID           sql.NullInt64
	LocationID       sql.NullInt64
	ShipID           sql.NullInt64
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersRow
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(
			&i.Character.ID,
			&i.Character.AssetValue,
			&i.Character.HomeID,
			&i.Character.LastLoginAt,
			&i.Character.LocationID,
			&i.Character.ShipID,
			&i.Character.TotalSp,
			&i.Character.UnallocatedSp,
			&i.Character.WalletBalance,
			&i.EveCharacter.AllianceID,
			&i.EveCharacter.Birthday,
			&i.EveCharacter.CorporationID,
			&i.EveCharacter.Description,
			&i.EveCharacter.Gender,
			&i.EveCharacter.FactionID,
			&i.EveCharacter.ID,
			&i.EveCharacter.Name,
			&i.EveCharacter.RaceID,
			&i.EveCharacter.SecurityStatus,
			&i.EveCharacter.Title,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveRace.ID,
			&i.EveRace.Description,
			&i.EveRace.Name,
			&i.AllianceName,
			&i.AllianceCategory,
			&i.FactionName,
			&i.FactionCategory,
			&i.HomeID,
			&i.LocationID,
			&i.ShipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersShort = `-- name: ListCharactersShort :many
SELECT DISTINCT eve_characters.id, eve_characters.name
FROM characters
JOIN eve_characters ON eve_characters.id = characters.id
ORDER BY eve_characters.name
`

type ListCharactersShortRow struct {
	ID   int64
	Name string
}

func (q *Queries) ListCharactersShort(ctx context.Context) ([]ListCharactersShortRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersShort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersShortRow
	for rows.Next() {
		var i ListCharactersShortRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterAssetValue = `-- name: UpdateCharacterAssetValue :exec
UPDATE characters
SET
    asset_value = ?
WHERE id = ?
`

type UpdateCharacterAssetValueParams struct {
	AssetValue sql.NullFloat64
	ID         int64
}

func (q *Queries) UpdateCharacterAssetValue(ctx context.Context, arg UpdateCharacterAssetValueParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterAssetValue, arg.AssetValue, arg.ID)
	return err
}

const updateCharacterHomeId = `-- name: UpdateCharacterHomeId :exec
UPDATE characters
SET
    home_id = ?
WHERE id = ?
`

type UpdateCharacterHomeIdParams struct {
	HomeID sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateCharacterHomeId(ctx context.Context, arg UpdateCharacterHomeIdParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterHomeId, arg.HomeID, arg.ID)
	return err
}

const updateCharacterLastLoginAt = `-- name: UpdateCharacterLastLoginAt :exec
UPDATE characters
SET
    last_login_at = ?
WHERE id = ?
`

type UpdateCharacterLastLoginAtParams struct {
	LastLoginAt sql.NullTime
	ID          int64
}

func (q *Queries) UpdateCharacterLastLoginAt(ctx context.Context, arg UpdateCharacterLastLoginAtParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterLastLoginAt, arg.LastLoginAt, arg.ID)
	return err
}

const updateCharacterLocationID = `-- name: UpdateCharacterLocationID :exec
UPDATE characters
SET
    location_id = ?
WHERE id = ?
`

type UpdateCharacterLocationIDParams struct {
	LocationID sql.NullInt64
	ID         int64
}

func (q *Queries) UpdateCharacterLocationID(ctx context.Context, arg UpdateCharacterLocationIDParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterLocationID, arg.LocationID, arg.ID)
	return err
}

const updateCharacterSP = `-- name: UpdateCharacterSP :exec
UPDATE characters
SET
    total_sp = ?,
    unallocated_sp = ?
WHERE id = ?
`

type UpdateCharacterSPParams struct {
	TotalSp       sql.NullInt64
	UnallocatedSp sql.NullInt64
	ID            int64
}

func (q *Queries) UpdateCharacterSP(ctx context.Context, arg UpdateCharacterSPParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterSP, arg.TotalSp, arg.UnallocatedSp, arg.ID)
	return err
}

const updateCharacterShipID = `-- name: UpdateCharacterShipID :exec
UPDATE characters
SET
    ship_id = ?
WHERE id = ?
`

type UpdateCharacterShipIDParams struct {
	ShipID sql.NullInt64
	ID     int64
}

func (q *Queries) UpdateCharacterShipID(ctx context.Context, arg UpdateCharacterShipIDParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterShipID, arg.ShipID, arg.ID)
	return err
}

const updateCharacterWalletBalance = `-- name: UpdateCharacterWalletBalance :exec
UPDATE characters
SET
    wallet_balance = ?
WHERE id = ?
`

type UpdateCharacterWalletBalanceParams struct {
	WalletBalance sql.NullFloat64
	ID            int64
}

func (q *Queries) UpdateCharacterWalletBalance(ctx context.Context, arg UpdateCharacterWalletBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterWalletBalance, arg.WalletBalance, arg.ID)
	return err
}

const updateOrCreateCharacter = `-- name: UpdateOrCreateCharacter :exec
INSERT INTO characters (
    id,
    home_id,
    last_login_at,
    location_id,
    ship_id,
    total_sp,
    unallocated_sp,
    wallet_balance,
    asset_value
)
VALUES (
    ?1, ?2, ?3, ?4, ?5 ,?6, ?7, ?8, ?9
)
ON CONFLICT(id) DO
UPDATE SET
    home_id = ?2,
    last_login_at = ?3,
    location_id = ?4,
    ship_id = ?5,
    total_sp = ?6,
    unallocated_sp = ?7,
    wallet_balance = ?8,
    asset_value = ?9
WHERE id = ?1
`

type UpdateOrCreateCharacterParams struct {
	ID            int64
	HomeID        sql.NullInt64
	LastLoginAt   sql.NullTime
	LocationID    sql.NullInt64
	ShipID        sql.NullInt64
	TotalSp       sql.NullInt64
	UnallocatedSp sql.NullInt64
	WalletBalance sql.NullFloat64
	AssetValue    sql.NullFloat64
}

func (q *Queries) UpdateOrCreateCharacter(ctx context.Context, arg UpdateOrCreateCharacterParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateCharacter,
		arg.ID,
		arg.HomeID,
		arg.LastLoginAt,
		arg.LocationID,
		arg.ShipID,
		arg.TotalSp,
		arg.UnallocatedSp,
		arg.WalletBalance,
		arg.AssetValue,
	)
	return err
}
