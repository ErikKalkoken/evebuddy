// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: character_industry_jobs.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const deleteCharacterIndustryJobs = `-- name: DeleteCharacterIndustryJobs :exec
DELETE FROM character_industry_jobs
WHERE
    character_id = ?
    AND job_id IN (/*SLICE:job_ids*/?)
`

type DeleteCharacterIndustryJobsParams struct {
	CharacterID int64
	JobIds      []int64
}

func (q *Queries) DeleteCharacterIndustryJobs(ctx context.Context, arg DeleteCharacterIndustryJobsParams) error {
	query := deleteCharacterIndustryJobs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.JobIds) > 0 {
		for _, v := range arg.JobIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:job_ids*/?", strings.Repeat(",?", len(arg.JobIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:job_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterIndustryJob = `-- name: GetCharacterIndustryJob :one
SELECT
    cij.id, cij.activity_id, cij.blueprint_id, cij.blueprint_location_id, cij.blueprint_type_id, cij.character_id, cij.completed_character_id, cij.completed_date, cij.cost, cij.duration, cij.end_date, cij.facility_id, cij.installer_id, cij.job_id, cij.licensed_runs, cij.output_location_id, cij.pause_date, cij.probability, cij.product_type_id, cij.runs, cij.start_date, cij.station_id, cij.status, cij.successful_runs,
    ic.id, ic.category, ic.name,
    bl.name AS blueprint_location_name,
    bls.security_status as blueprint_location_security,
    bt.name AS blueprint_type_name,
    cc.name AS completed_character_name,
    fc.name AS facility_name,
    fcs.security_status as facility_security,
    ol.name AS output_location_name,
    ols.security_status as output_location_security,
    pt.name AS product_type_name,
    sl.name AS station_name,
    sls.security_status as station_security
FROM
    character_industry_jobs cij
    JOIN eve_locations bl ON bl.id = cij.blueprint_location_id
    JOIN eve_types bt ON bt.id = cij.blueprint_type_id
    JOIN eve_locations fc ON fc.id = cij.facility_id
    JOIN eve_entities ic ON ic.id = cij.installer_id
    JOIN eve_locations ol ON ol.id = cij.output_location_id
    JOIN eve_locations sl ON sl.id = cij.station_id
    LEFT JOIN eve_solar_systems bls ON bls.id = bl.eve_solar_system_id
    LEFT JOIN eve_solar_systems fcs ON fcs.id = fc.eve_solar_system_id
    LEFT JOIN eve_solar_systems sls ON sls.id = sl.eve_solar_system_id
    LEFT JOIN eve_solar_systems ols ON ols.id = ol.eve_solar_system_id
    LEFT JOIN eve_entities cc ON cc.id = cij.completed_character_id
    LEFT JOIN eve_types pt ON pt.id = cij.product_type_id
WHERE
    character_id = ?
    AND job_id = ?
`

type GetCharacterIndustryJobParams struct {
	CharacterID int64
	JobID       int64
}

type GetCharacterIndustryJobRow struct {
	CharacterIndustryJob      CharacterIndustryJob
	EveEntity                 EveEntity
	BlueprintLocationName     string
	BlueprintLocationSecurity sql.NullFloat64
	BlueprintTypeName         string
	CompletedCharacterName    sql.NullString
	FacilityName              string
	FacilitySecurity          sql.NullFloat64
	OutputLocationName        string
	OutputLocationSecurity    sql.NullFloat64
	ProductTypeName           sql.NullString
	StationName               string
	StationSecurity           sql.NullFloat64
}

func (q *Queries) GetCharacterIndustryJob(ctx context.Context, arg GetCharacterIndustryJobParams) (GetCharacterIndustryJobRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterIndustryJob, arg.CharacterID, arg.JobID)
	var i GetCharacterIndustryJobRow
	err := row.Scan(
		&i.CharacterIndustryJob.ID,
		&i.CharacterIndustryJob.ActivityID,
		&i.CharacterIndustryJob.BlueprintID,
		&i.CharacterIndustryJob.BlueprintLocationID,
		&i.CharacterIndustryJob.BlueprintTypeID,
		&i.CharacterIndustryJob.CharacterID,
		&i.CharacterIndustryJob.CompletedCharacterID,
		&i.CharacterIndustryJob.CompletedDate,
		&i.CharacterIndustryJob.Cost,
		&i.CharacterIndustryJob.Duration,
		&i.CharacterIndustryJob.EndDate,
		&i.CharacterIndustryJob.FacilityID,
		&i.CharacterIndustryJob.InstallerID,
		&i.CharacterIndustryJob.JobID,
		&i.CharacterIndustryJob.LicensedRuns,
		&i.CharacterIndustryJob.OutputLocationID,
		&i.CharacterIndustryJob.PauseDate,
		&i.CharacterIndustryJob.Probability,
		&i.CharacterIndustryJob.ProductTypeID,
		&i.CharacterIndustryJob.Runs,
		&i.CharacterIndustryJob.StartDate,
		&i.CharacterIndustryJob.StationID,
		&i.CharacterIndustryJob.Status,
		&i.CharacterIndustryJob.SuccessfulRuns,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.BlueprintLocationName,
		&i.BlueprintLocationSecurity,
		&i.BlueprintTypeName,
		&i.CompletedCharacterName,
		&i.FacilityName,
		&i.FacilitySecurity,
		&i.OutputLocationName,
		&i.OutputLocationSecurity,
		&i.ProductTypeName,
		&i.StationName,
		&i.StationSecurity,
	)
	return i, err
}

const listAllCharacterIndustryJobActiveCounts = `-- name: ListAllCharacterIndustryJobActiveCounts :many
SELECT
    installer_id,
    activity_id,
    status,
    count(id) as number
FROM
    (
        SELECT
            id,
            installer_id,
            activity_id,
            status
        FROM
            character_industry_jobs j1
        UNION ALL
        SELECT
            j2.id,
            installer_id,
            activity_id,
            status
        FROM
            corporation_industry_jobs j2
            JOIN characters c ON c.id == j2.installer_id
    ) AS jobs
WHERE
    status = "active"
    OR status = "ready"
GROUP BY
    installer_id,
    activity_id,
    status
`

type ListAllCharacterIndustryJobActiveCountsRow struct {
	InstallerID int64
	ActivityID  int64
	Status      string
	Number      int64
}

func (q *Queries) ListAllCharacterIndustryJobActiveCounts(ctx context.Context) ([]ListAllCharacterIndustryJobActiveCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterIndustryJobActiveCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterIndustryJobActiveCountsRow
	for rows.Next() {
		var i ListAllCharacterIndustryJobActiveCountsRow
		if err := rows.Scan(
			&i.InstallerID,
			&i.ActivityID,
			&i.Status,
			&i.Number,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCharacterIndustryJobs = `-- name: ListAllCharacterIndustryJobs :many
SELECT
    cij.id, cij.activity_id, cij.blueprint_id, cij.blueprint_location_id, cij.blueprint_type_id, cij.character_id, cij.completed_character_id, cij.completed_date, cij.cost, cij.duration, cij.end_date, cij.facility_id, cij.installer_id, cij.job_id, cij.licensed_runs, cij.output_location_id, cij.pause_date, cij.probability, cij.product_type_id, cij.runs, cij.start_date, cij.station_id, cij.status, cij.successful_runs,
    ic.id, ic.category, ic.name,
    bl.name AS blueprint_location_name,
    bls.security_status as blueprint_location_security,
    bt.name AS blueprint_type_name,
    cc.name AS completed_character_name,
    fc.name AS facility_name,
    fcs.security_status as facility_security,
    ol.name AS output_location_name,
    ols.security_status as output_location_security,
    pt.name AS product_type_name,
    sl.name AS station_name,
    sls.security_status as station_security
FROM
    character_industry_jobs cij
    JOIN eve_locations bl ON bl.id = cij.blueprint_location_id
    JOIN eve_types bt ON bt.id = cij.blueprint_type_id
    JOIN eve_locations fc ON fc.id = cij.facility_id
    JOIN eve_entities ic ON ic.id = cij.installer_id
    JOIN eve_locations ol ON ol.id = cij.output_location_id
    JOIN eve_locations sl ON sl.id = cij.station_id
    LEFT JOIN eve_solar_systems bls ON bls.id = bl.eve_solar_system_id
    LEFT JOIN eve_solar_systems fcs ON fcs.id = fc.eve_solar_system_id
    LEFT JOIN eve_solar_systems ols ON ols.id = ol.eve_solar_system_id
    LEFT JOIN eve_solar_systems sls ON sls.id = sl.eve_solar_system_id
    LEFT JOIN eve_entities cc ON cc.id = cij.completed_character_id
    LEFT JOIN eve_types pt ON pt.id = cij.product_type_id
`

type ListAllCharacterIndustryJobsRow struct {
	CharacterIndustryJob      CharacterIndustryJob
	EveEntity                 EveEntity
	BlueprintLocationName     string
	BlueprintLocationSecurity sql.NullFloat64
	BlueprintTypeName         string
	CompletedCharacterName    sql.NullString
	FacilityName              string
	FacilitySecurity          sql.NullFloat64
	OutputLocationName        string
	OutputLocationSecurity    sql.NullFloat64
	ProductTypeName           sql.NullString
	StationName               string
	StationSecurity           sql.NullFloat64
}

func (q *Queries) ListAllCharacterIndustryJobs(ctx context.Context) ([]ListAllCharacterIndustryJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterIndustryJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterIndustryJobsRow
	for rows.Next() {
		var i ListAllCharacterIndustryJobsRow
		if err := rows.Scan(
			&i.CharacterIndustryJob.ID,
			&i.CharacterIndustryJob.ActivityID,
			&i.CharacterIndustryJob.BlueprintID,
			&i.CharacterIndustryJob.BlueprintLocationID,
			&i.CharacterIndustryJob.BlueprintTypeID,
			&i.CharacterIndustryJob.CharacterID,
			&i.CharacterIndustryJob.CompletedCharacterID,
			&i.CharacterIndustryJob.CompletedDate,
			&i.CharacterIndustryJob.Cost,
			&i.CharacterIndustryJob.Duration,
			&i.CharacterIndustryJob.EndDate,
			&i.CharacterIndustryJob.FacilityID,
			&i.CharacterIndustryJob.InstallerID,
			&i.CharacterIndustryJob.JobID,
			&i.CharacterIndustryJob.LicensedRuns,
			&i.CharacterIndustryJob.OutputLocationID,
			&i.CharacterIndustryJob.PauseDate,
			&i.CharacterIndustryJob.Probability,
			&i.CharacterIndustryJob.ProductTypeID,
			&i.CharacterIndustryJob.Runs,
			&i.CharacterIndustryJob.StartDate,
			&i.CharacterIndustryJob.StationID,
			&i.CharacterIndustryJob.Status,
			&i.CharacterIndustryJob.SuccessfulRuns,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.BlueprintLocationName,
			&i.BlueprintLocationSecurity,
			&i.BlueprintTypeName,
			&i.CompletedCharacterName,
			&i.FacilityName,
			&i.FacilitySecurity,
			&i.OutputLocationName,
			&i.OutputLocationSecurity,
			&i.ProductTypeName,
			&i.StationName,
			&i.StationSecurity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterIndustryJobs = `-- name: ListCharacterIndustryJobs :many
SELECT
    cij.id, cij.activity_id, cij.blueprint_id, cij.blueprint_location_id, cij.blueprint_type_id, cij.character_id, cij.completed_character_id, cij.completed_date, cij.cost, cij.duration, cij.end_date, cij.facility_id, cij.installer_id, cij.job_id, cij.licensed_runs, cij.output_location_id, cij.pause_date, cij.probability, cij.product_type_id, cij.runs, cij.start_date, cij.station_id, cij.status, cij.successful_runs,
    ic.id, ic.category, ic.name,
    bl.name AS blueprint_location_name,
    bls.security_status as blueprint_location_security,
    bt.name AS blueprint_type_name,
    cc.name AS completed_character_name,
    fc.name AS facility_name,
    fcs.security_status as facility_security,
    ol.name AS output_location_name,
    ols.security_status as output_location_security,
    pt.name AS product_type_name,
    sl.name AS station_name,
    sls.security_status as station_security
FROM
    character_industry_jobs cij
    JOIN eve_locations bl ON bl.id = cij.blueprint_location_id
    JOIN eve_types bt ON bt.id = cij.blueprint_type_id
    JOIN eve_locations fc ON fc.id = cij.facility_id
    JOIN eve_entities ic ON ic.id = cij.installer_id
    JOIN eve_locations ol ON ol.id = cij.output_location_id
    JOIN eve_locations sl ON sl.id = cij.station_id
    LEFT JOIN eve_solar_systems bls ON bls.id = bl.eve_solar_system_id
    LEFT JOIN eve_solar_systems fcs ON fcs.id = fc.eve_solar_system_id
    LEFT JOIN eve_solar_systems ols ON ols.id = ol.eve_solar_system_id
    LEFT JOIN eve_solar_systems sls ON sls.id = sl.eve_solar_system_id
    LEFT JOIN eve_entities cc ON cc.id = cij.completed_character_id
    LEFT JOIN eve_types pt ON pt.id = cij.product_type_id
WHERE
    character_id = ?
`

type ListCharacterIndustryJobsRow struct {
	CharacterIndustryJob      CharacterIndustryJob
	EveEntity                 EveEntity
	BlueprintLocationName     string
	BlueprintLocationSecurity sql.NullFloat64
	BlueprintTypeName         string
	CompletedCharacterName    sql.NullString
	FacilityName              string
	FacilitySecurity          sql.NullFloat64
	OutputLocationName        string
	OutputLocationSecurity    sql.NullFloat64
	ProductTypeName           sql.NullString
	StationName               string
	StationSecurity           sql.NullFloat64
}

func (q *Queries) ListCharacterIndustryJobs(ctx context.Context, characterID int64) ([]ListCharacterIndustryJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterIndustryJobs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterIndustryJobsRow
	for rows.Next() {
		var i ListCharacterIndustryJobsRow
		if err := rows.Scan(
			&i.CharacterIndustryJob.ID,
			&i.CharacterIndustryJob.ActivityID,
			&i.CharacterIndustryJob.BlueprintID,
			&i.CharacterIndustryJob.BlueprintLocationID,
			&i.CharacterIndustryJob.BlueprintTypeID,
			&i.CharacterIndustryJob.CharacterID,
			&i.CharacterIndustryJob.CompletedCharacterID,
			&i.CharacterIndustryJob.CompletedDate,
			&i.CharacterIndustryJob.Cost,
			&i.CharacterIndustryJob.Duration,
			&i.CharacterIndustryJob.EndDate,
			&i.CharacterIndustryJob.FacilityID,
			&i.CharacterIndustryJob.InstallerID,
			&i.CharacterIndustryJob.JobID,
			&i.CharacterIndustryJob.LicensedRuns,
			&i.CharacterIndustryJob.OutputLocationID,
			&i.CharacterIndustryJob.PauseDate,
			&i.CharacterIndustryJob.Probability,
			&i.CharacterIndustryJob.ProductTypeID,
			&i.CharacterIndustryJob.Runs,
			&i.CharacterIndustryJob.StartDate,
			&i.CharacterIndustryJob.StationID,
			&i.CharacterIndustryJob.Status,
			&i.CharacterIndustryJob.SuccessfulRuns,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.BlueprintLocationName,
			&i.BlueprintLocationSecurity,
			&i.BlueprintTypeName,
			&i.CompletedCharacterName,
			&i.FacilityName,
			&i.FacilitySecurity,
			&i.OutputLocationName,
			&i.OutputLocationSecurity,
			&i.ProductTypeName,
			&i.StationName,
			&i.StationSecurity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterIndustryJobStatus = `-- name: UpdateCharacterIndustryJobStatus :exec
UPDATE character_industry_jobs
SET
    status = ?
WHERE
    character_id = ?
    AND job_id IN (/*SLICE:job_ids*/?)
`

type UpdateCharacterIndustryJobStatusParams struct {
	Status      string
	CharacterID int64
	JobIds      []int64
}

func (q *Queries) UpdateCharacterIndustryJobStatus(ctx context.Context, arg UpdateCharacterIndustryJobStatusParams) error {
	query := updateCharacterIndustryJobStatus
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Status)
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.JobIds) > 0 {
		for _, v := range arg.JobIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:job_ids*/?", strings.Repeat(",?", len(arg.JobIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:job_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const updateOrCreateCharacterIndustryJobs = `-- name: UpdateOrCreateCharacterIndustryJobs :exec
INSERT INTO
    character_industry_jobs (
        activity_id,
        blueprint_id,
        blueprint_location_id,
        blueprint_type_id,
        character_id,
        completed_character_id,
        completed_date,
        cost,
        duration,
        end_date,
        facility_id,
        installer_id,
        job_id,
        licensed_runs,
        output_location_id,
        pause_date,
        probability,
        product_type_id,
        runs,
        start_date,
        station_id,
        status,
        successful_runs
    )
VALUES
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14,
        ?15,
        ?16,
        ?17,
        ?18,
        ?19,
        ?20,
        ?21,
        ?22,
        ?23
    )
ON CONFLICT (character_id, job_id) DO UPDATE
SET
    completed_character_id = ?6,
    completed_date = ?7,
    end_date = ?10,
    pause_date = ?16,
    status = ?22,
    successful_runs = ?23
`

type UpdateOrCreateCharacterIndustryJobsParams struct {
	ActivityID           int64
	BlueprintID          int64
	BlueprintLocationID  int64
	BlueprintTypeID      int64
	CharacterID          int64
	CompletedCharacterID sql.NullInt64
	CompletedDate        sql.NullTime
	Cost                 sql.NullFloat64
	Duration             int64
	EndDate              time.Time
	FacilityID           int64
	InstallerID          int64
	JobID                int64
	LicensedRuns         sql.NullInt64
	OutputLocationID     int64
	PauseDate            sql.NullTime
	Probability          sql.NullFloat64
	ProductTypeID        sql.NullInt64
	Runs                 int64
	StartDate            time.Time
	StationID            int64
	Status               string
	SuccessfulRuns       sql.NullInt64
}

func (q *Queries) UpdateOrCreateCharacterIndustryJobs(ctx context.Context, arg UpdateOrCreateCharacterIndustryJobsParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateCharacterIndustryJobs,
		arg.ActivityID,
		arg.BlueprintID,
		arg.BlueprintLocationID,
		arg.BlueprintTypeID,
		arg.CharacterID,
		arg.CompletedCharacterID,
		arg.CompletedDate,
		arg.Cost,
		arg.Duration,
		arg.EndDate,
		arg.FacilityID,
		arg.InstallerID,
		arg.JobID,
		arg.LicensedRuns,
		arg.OutputLocationID,
		arg.PauseDate,
		arg.Probability,
		arg.ProductTypeID,
		arg.Runs,
		arg.StartDate,
		arg.StationID,
		arg.Status,
		arg.SuccessfulRuns,
	)
	return err
}
