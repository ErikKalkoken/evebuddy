// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: character_wallet_journal.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCharacterWalletJournalEntry = `-- name: CreateCharacterWalletJournalEntry :exec
INSERT INTO character_wallet_journal_entries (
    amount,
    balance,
    context_id,
    context_id_type,
    date,
    description,
    first_party_id,
    ref_id,
    character_id,
    reason,
    ref_type,
    second_party_id,
    tax,
    tax_receiver_id
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCharacterWalletJournalEntryParams struct {
	Amount        float64
	Balance       float64
	ContextID     int64
	ContextIDType string
	Date          time.Time
	Description   string
	FirstPartyID  sql.NullInt64
	RefID         int64
	CharacterID   int64
	Reason        string
	RefType       string
	SecondPartyID sql.NullInt64
	Tax           float64
	TaxReceiverID sql.NullInt64
}

func (q *Queries) CreateCharacterWalletJournalEntry(ctx context.Context, arg CreateCharacterWalletJournalEntryParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterWalletJournalEntry,
		arg.Amount,
		arg.Balance,
		arg.ContextID,
		arg.ContextIDType,
		arg.Date,
		arg.Description,
		arg.FirstPartyID,
		arg.RefID,
		arg.CharacterID,
		arg.Reason,
		arg.RefType,
		arg.SecondPartyID,
		arg.Tax,
		arg.TaxReceiverID,
	)
	return err
}

const getCharacterWalletJournalEntry = `-- name: GetCharacterWalletJournalEntry :one
SELECT
    wje.id, wje.amount, wje.balance, wje.character_id, wje.context_id, wje.context_id_type, wje.date, wje.description, wje.first_party_id, wje.ref_id, wje.reason, wje.ref_type, wje.second_party_id, wje.tax, wje.tax_receiver_id,
    fp.name as first_name,
    fp.category as first_category,
    sp.name as second_name,
    sp.category as second_category,
    tr.name as tax_name,
    tr.category as tax_category
FROM character_wallet_journal_entries wje
LEFT JOIN eve_entities AS fp ON fp.id = wje.first_party_id
LEFT JOIN eve_entities AS sp ON sp.id = wje.second_party_id
LEFT JOIN eve_entities AS tr ON tr.id = wje.tax_receiver_id
WHERE character_id = ? and wje.ref_id = ?
`

type GetCharacterWalletJournalEntryParams struct {
	CharacterID int64
	RefID       int64
}

type GetCharacterWalletJournalEntryRow struct {
	CharacterWalletJournalEntry CharacterWalletJournalEntry
	FirstName                   sql.NullString
	FirstCategory               sql.NullString
	SecondName                  sql.NullString
	SecondCategory              sql.NullString
	TaxName                     sql.NullString
	TaxCategory                 sql.NullString
}

func (q *Queries) GetCharacterWalletJournalEntry(ctx context.Context, arg GetCharacterWalletJournalEntryParams) (GetCharacterWalletJournalEntryRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterWalletJournalEntry, arg.CharacterID, arg.RefID)
	var i GetCharacterWalletJournalEntryRow
	err := row.Scan(
		&i.CharacterWalletJournalEntry.ID,
		&i.CharacterWalletJournalEntry.Amount,
		&i.CharacterWalletJournalEntry.Balance,
		&i.CharacterWalletJournalEntry.CharacterID,
		&i.CharacterWalletJournalEntry.ContextID,
		&i.CharacterWalletJournalEntry.ContextIDType,
		&i.CharacterWalletJournalEntry.Date,
		&i.CharacterWalletJournalEntry.Description,
		&i.CharacterWalletJournalEntry.FirstPartyID,
		&i.CharacterWalletJournalEntry.RefID,
		&i.CharacterWalletJournalEntry.Reason,
		&i.CharacterWalletJournalEntry.RefType,
		&i.CharacterWalletJournalEntry.SecondPartyID,
		&i.CharacterWalletJournalEntry.Tax,
		&i.CharacterWalletJournalEntry.TaxReceiverID,
		&i.FirstName,
		&i.FirstCategory,
		&i.SecondName,
		&i.SecondCategory,
		&i.TaxName,
		&i.TaxCategory,
	)
	return i, err
}

const listCharacterWalletJournalEntries = `-- name: ListCharacterWalletJournalEntries :many
SELECT
    wje.id, wje.amount, wje.balance, wje.character_id, wje.context_id, wje.context_id_type, wje.date, wje.description, wje.first_party_id, wje.ref_id, wje.reason, wje.ref_type, wje.second_party_id, wje.tax, wje.tax_receiver_id,
    fp.name as first_name,
    fp.category as first_category,
    sp.name as second_name,
    sp.category as second_category,
    tr.name as tax_name,
    tr.category as tax_category
FROM character_wallet_journal_entries wje
LEFT JOIN eve_entities AS fp ON fp.id = wje.first_party_id
LEFT JOIN eve_entities AS sp ON sp.id = wje.second_party_id
LEFT JOIN eve_entities AS tr ON tr.id = wje.tax_receiver_id
WHERE character_id = ?
ORDER BY date DESC
`

type ListCharacterWalletJournalEntriesRow struct {
	CharacterWalletJournalEntry CharacterWalletJournalEntry
	FirstName                   sql.NullString
	FirstCategory               sql.NullString
	SecondName                  sql.NullString
	SecondCategory              sql.NullString
	TaxName                     sql.NullString
	TaxCategory                 sql.NullString
}

func (q *Queries) ListCharacterWalletJournalEntries(ctx context.Context, characterID int64) ([]ListCharacterWalletJournalEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletJournalEntries, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterWalletJournalEntriesRow
	for rows.Next() {
		var i ListCharacterWalletJournalEntriesRow
		if err := rows.Scan(
			&i.CharacterWalletJournalEntry.ID,
			&i.CharacterWalletJournalEntry.Amount,
			&i.CharacterWalletJournalEntry.Balance,
			&i.CharacterWalletJournalEntry.CharacterID,
			&i.CharacterWalletJournalEntry.ContextID,
			&i.CharacterWalletJournalEntry.ContextIDType,
			&i.CharacterWalletJournalEntry.Date,
			&i.CharacterWalletJournalEntry.Description,
			&i.CharacterWalletJournalEntry.FirstPartyID,
			&i.CharacterWalletJournalEntry.RefID,
			&i.CharacterWalletJournalEntry.Reason,
			&i.CharacterWalletJournalEntry.RefType,
			&i.CharacterWalletJournalEntry.SecondPartyID,
			&i.CharacterWalletJournalEntry.Tax,
			&i.CharacterWalletJournalEntry.TaxReceiverID,
			&i.FirstName,
			&i.FirstCategory,
			&i.SecondName,
			&i.SecondCategory,
			&i.TaxName,
			&i.TaxCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterWalletJournalEntryRefIDs = `-- name: ListCharacterWalletJournalEntryRefIDs :many
SELECT ref_id
FROM character_wallet_journal_entries
WHERE character_id = ?
`

func (q *Queries) ListCharacterWalletJournalEntryRefIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterWalletJournalEntryRefIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var ref_id int64
		if err := rows.Scan(&ref_id); err != nil {
			return nil, err
		}
		items = append(items, ref_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
