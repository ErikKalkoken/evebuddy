// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: corporation_contracts.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCorporationContract = `-- name: CreateCorporationContract :one
INSERT INTO
    corporation_contracts (
        acceptor_id,
        assignee_id,
        availability,
        buyout,
        corporation_id,
        collateral,
        contract_id,
        date_accepted,
        date_completed,
        date_expired,
        date_issued,
        days_to_complete,
        end_location_id,
        for_corporation,
        issuer_corporation_id,
        issuer_id,
        price,
        reward,
        start_location_id,
        status,
        status_notified,
        title,
        type,
        updated_at,
        volume
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    ) RETURNING id
`

type CreateCorporationContractParams struct {
	AcceptorID          sql.NullInt64
	AssigneeID          sql.NullInt64
	Availability        string
	Buyout              float64
	CorporationID       int64
	Collateral          float64
	ContractID          int64
	DateAccepted        sql.NullTime
	DateCompleted       sql.NullTime
	DateExpired         time.Time
	DateIssued          time.Time
	DaysToComplete      int64
	EndLocationID       sql.NullInt64
	ForCorporation      bool
	IssuerCorporationID int64
	IssuerID            int64
	Price               float64
	Reward              float64
	StartLocationID     sql.NullInt64
	Status              string
	StatusNotified      string
	Title               string
	Type                string
	UpdatedAt           time.Time
	Volume              float64
}

func (q *Queries) CreateCorporationContract(ctx context.Context, arg CreateCorporationContractParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createCorporationContract,
		arg.AcceptorID,
		arg.AssigneeID,
		arg.Availability,
		arg.Buyout,
		arg.CorporationID,
		arg.Collateral,
		arg.ContractID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.DateExpired,
		arg.DateIssued,
		arg.DaysToComplete,
		arg.EndLocationID,
		arg.ForCorporation,
		arg.IssuerCorporationID,
		arg.IssuerID,
		arg.Price,
		arg.Reward,
		arg.StartLocationID,
		arg.Status,
		arg.StatusNotified,
		arg.Title,
		arg.Type,
		arg.UpdatedAt,
		arg.Volume,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCorporationContractBid = `-- name: CreateCorporationContractBid :exec
INSERT INTO
    corporation_contract_bids (
        contract_id,
        amount,
        bid_id,
        bidder_id,
        date_bid
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?
    )
`

type CreateCorporationContractBidParams struct {
	ContractID int64
	Amount     float64
	BidID      int64
	BidderID   int64
	DateBid    time.Time
}

func (q *Queries) CreateCorporationContractBid(ctx context.Context, arg CreateCorporationContractBidParams) error {
	_, err := q.db.ExecContext(ctx, createCorporationContractBid,
		arg.ContractID,
		arg.Amount,
		arg.BidID,
		arg.BidderID,
		arg.DateBid,
	)
	return err
}

const createCorporationContractItem = `-- name: CreateCorporationContractItem :exec
INSERT INTO
    corporation_contract_items (
        contract_id,
        is_included,
        is_singleton,
        quantity,
        raw_quantity,
        record_id,
        type_id
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
`

type CreateCorporationContractItemParams struct {
	ContractID  int64
	IsIncluded  bool
	IsSingleton bool
	Quantity    int64
	RawQuantity int64
	RecordID    int64
	TypeID      int64
}

func (q *Queries) CreateCorporationContractItem(ctx context.Context, arg CreateCorporationContractItemParams) error {
	_, err := q.db.ExecContext(ctx, createCorporationContractItem,
		arg.ContractID,
		arg.IsIncluded,
		arg.IsSingleton,
		arg.Quantity,
		arg.RawQuantity,
		arg.RecordID,
		arg.TypeID,
	)
	return err
}

const getCorporationContract = `-- name: GetCorporationContract :one
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.corporation_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            corporation_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    corporation_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    corporation_id = ?
    AND cc.contract_id = ?
`

type GetCorporationContractParams struct {
	CorporationID int64
	ContractID    int64
}

type GetCorporationContractRow struct {
	CorporationContract            CorporationContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) GetCorporationContract(ctx context.Context, arg GetCorporationContractParams) (GetCorporationContractRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporationContract, arg.CorporationID, arg.ContractID)
	var i GetCorporationContractRow
	err := row.Scan(
		&i.CorporationContract.ID,
		&i.CorporationContract.AcceptorID,
		&i.CorporationContract.AssigneeID,
		&i.CorporationContract.Availability,
		&i.CorporationContract.Buyout,
		&i.CorporationContract.CorporationID,
		&i.CorporationContract.Collateral,
		&i.CorporationContract.ContractID,
		&i.CorporationContract.DateAccepted,
		&i.CorporationContract.DateCompleted,
		&i.CorporationContract.DateExpired,
		&i.CorporationContract.DateIssued,
		&i.CorporationContract.DaysToComplete,
		&i.CorporationContract.EndLocationID,
		&i.CorporationContract.ForCorporation,
		&i.CorporationContract.IssuerCorporationID,
		&i.CorporationContract.IssuerID,
		&i.CorporationContract.Price,
		&i.CorporationContract.Reward,
		&i.CorporationContract.StartLocationID,
		&i.CorporationContract.Status,
		&i.CorporationContract.StatusNotified,
		&i.CorporationContract.Title,
		&i.CorporationContract.Type,
		&i.CorporationContract.UpdatedAt,
		&i.CorporationContract.Volume,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveEntity_2.ID,
		&i.EveEntity_2.Category,
		&i.EveEntity_2.Name,
		&i.AcceptorName,
		&i.AcceptorCategory,
		&i.AssigneeName,
		&i.AssigneeCategory,
		&i.EndLocationName,
		&i.StartLocationName,
		&i.EndSolarSystemID,
		&i.EndSolarSystemName,
		&i.EndSolarSystemSecurityStatus,
		&i.StartSolarSystemID,
		&i.StartSolarSystemName,
		&i.StartSolarSystemSecurityStatus,
		&i.Items,
	)
	return i, err
}

const getCorporationContractBid = `-- name: GetCorporationContractBid :one
SELECT
    ccb.id, ccb.contract_id, ccb.amount, ccb.bid_id, ccb.bidder_id, ccb.date_bid,
    ee.id, ee.category, ee.name
FROM
    corporation_contract_bids ccb
    JOIN eve_entities ee ON ee.id = ccb.bidder_id
WHERE
    contract_id = ?
    AND bid_id = ?
`

type GetCorporationContractBidParams struct {
	ContractID int64
	BidID      int64
}

type GetCorporationContractBidRow struct {
	CorporationContractBid CorporationContractBid
	EveEntity              EveEntity
}

func (q *Queries) GetCorporationContractBid(ctx context.Context, arg GetCorporationContractBidParams) (GetCorporationContractBidRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporationContractBid, arg.ContractID, arg.BidID)
	var i GetCorporationContractBidRow
	err := row.Scan(
		&i.CorporationContractBid.ID,
		&i.CorporationContractBid.ContractID,
		&i.CorporationContractBid.Amount,
		&i.CorporationContractBid.BidID,
		&i.CorporationContractBid.BidderID,
		&i.CorporationContractBid.DateBid,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
	)
	return i, err
}

const getCorporationContractItem = `-- name: GetCorporationContractItem :one
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    corporation_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
    AND record_id = ?
`

type GetCorporationContractItemParams struct {
	ContractID int64
	RecordID   int64
}

type GetCorporationContractItemRow struct {
	CorporationContractItem CorporationContractItem
	EveType                 EveType
	EveGroup                EveGroup
	EveCategory             EveCategory
}

func (q *Queries) GetCorporationContractItem(ctx context.Context, arg GetCorporationContractItemParams) (GetCorporationContractItemRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporationContractItem, arg.ContractID, arg.RecordID)
	var i GetCorporationContractItemRow
	err := row.Scan(
		&i.CorporationContractItem.ID,
		&i.CorporationContractItem.ContractID,
		&i.CorporationContractItem.IsIncluded,
		&i.CorporationContractItem.IsSingleton,
		&i.CorporationContractItem.Quantity,
		&i.CorporationContractItem.RawQuantity,
		&i.CorporationContractItem.RecordID,
		&i.CorporationContractItem.TypeID,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
	)
	return i, err
}

const listAllCorporationContracts = `-- name: ListAllCorporationContracts :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.corporation_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            corporation_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    corporation_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
GROUP BY
    corporation_id, contract_id
ORDER BY
    date_issued DESC
`

type ListAllCorporationContractsRow struct {
	CorporationContract            CorporationContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) ListAllCorporationContracts(ctx context.Context) ([]ListAllCorporationContractsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCorporationContracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCorporationContractsRow
	for rows.Next() {
		var i ListAllCorporationContractsRow
		if err := rows.Scan(
			&i.CorporationContract.ID,
			&i.CorporationContract.AcceptorID,
			&i.CorporationContract.AssigneeID,
			&i.CorporationContract.Availability,
			&i.CorporationContract.Buyout,
			&i.CorporationContract.CorporationID,
			&i.CorporationContract.Collateral,
			&i.CorporationContract.ContractID,
			&i.CorporationContract.DateAccepted,
			&i.CorporationContract.DateCompleted,
			&i.CorporationContract.DateExpired,
			&i.CorporationContract.DateIssued,
			&i.CorporationContract.DaysToComplete,
			&i.CorporationContract.EndLocationID,
			&i.CorporationContract.ForCorporation,
			&i.CorporationContract.IssuerCorporationID,
			&i.CorporationContract.IssuerID,
			&i.CorporationContract.Price,
			&i.CorporationContract.Reward,
			&i.CorporationContract.StartLocationID,
			&i.CorporationContract.Status,
			&i.CorporationContract.StatusNotified,
			&i.CorporationContract.Title,
			&i.CorporationContract.Type,
			&i.CorporationContract.UpdatedAt,
			&i.CorporationContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.EndSolarSystemSecurityStatus,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.StartSolarSystemSecurityStatus,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationContractBidIDs = `-- name: ListCorporationContractBidIDs :many
SELECT
    bid_id
FROM
    corporation_contract_bids
WHERE
    contract_id = ?
`

func (q *Queries) ListCorporationContractBidIDs(ctx context.Context, contractID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationContractBidIDs, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var bid_id int64
		if err := rows.Scan(&bid_id); err != nil {
			return nil, err
		}
		items = append(items, bid_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationContractBids = `-- name: ListCorporationContractBids :many
SELECT
    ccb.id, ccb.contract_id, ccb.amount, ccb.bid_id, ccb.bidder_id, ccb.date_bid,
    ee.id, ee.category, ee.name
FROM
    corporation_contract_bids ccb
    JOIN eve_entities ee ON ee.id = ccb.bidder_id
WHERE
    contract_id = ?
`

type ListCorporationContractBidsRow struct {
	CorporationContractBid CorporationContractBid
	EveEntity              EveEntity
}

func (q *Queries) ListCorporationContractBids(ctx context.Context, contractID int64) ([]ListCorporationContractBidsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationContractBids, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationContractBidsRow
	for rows.Next() {
		var i ListCorporationContractBidsRow
		if err := rows.Scan(
			&i.CorporationContractBid.ID,
			&i.CorporationContractBid.ContractID,
			&i.CorporationContractBid.Amount,
			&i.CorporationContractBid.BidID,
			&i.CorporationContractBid.BidderID,
			&i.CorporationContractBid.DateBid,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationContractIDs = `-- name: ListCorporationContractIDs :many
SELECT
    contract_id
FROM
    corporation_contracts
WHERE
    corporation_id = ?
`

func (q *Queries) ListCorporationContractIDs(ctx context.Context, corporationID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationContractIDs, corporationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var contract_id int64
		if err := rows.Scan(&contract_id); err != nil {
			return nil, err
		}
		items = append(items, contract_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationContractItems = `-- name: ListCorporationContractItems :many
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    corporation_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
`

type ListCorporationContractItemsRow struct {
	CorporationContractItem CorporationContractItem
	EveType                 EveType
	EveGroup                EveGroup
	EveCategory             EveCategory
}

func (q *Queries) ListCorporationContractItems(ctx context.Context, contractID int64) ([]ListCorporationContractItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationContractItems, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationContractItemsRow
	for rows.Next() {
		var i ListCorporationContractItemsRow
		if err := rows.Scan(
			&i.CorporationContractItem.ID,
			&i.CorporationContractItem.ContractID,
			&i.CorporationContractItem.IsIncluded,
			&i.CorporationContractItem.IsSingleton,
			&i.CorporationContractItem.Quantity,
			&i.CorporationContractItem.RawQuantity,
			&i.CorporationContractItem.RecordID,
			&i.CorporationContractItem.TypeID,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationContractsForNotify = `-- name: ListCorporationContractsForNotify :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.corporation_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            corporation_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    corporation_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    corporation_id = ?
    AND status <> "deleted"
    AND cc.updated_at > ?
`

type ListCorporationContractsForNotifyParams struct {
	CorporationID int64
	UpdatedAt     time.Time
}

type ListCorporationContractsForNotifyRow struct {
	CorporationContract            CorporationContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) ListCorporationContractsForNotify(ctx context.Context, arg ListCorporationContractsForNotifyParams) ([]ListCorporationContractsForNotifyRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationContractsForNotify, arg.CorporationID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationContractsForNotifyRow
	for rows.Next() {
		var i ListCorporationContractsForNotifyRow
		if err := rows.Scan(
			&i.CorporationContract.ID,
			&i.CorporationContract.AcceptorID,
			&i.CorporationContract.AssigneeID,
			&i.CorporationContract.Availability,
			&i.CorporationContract.Buyout,
			&i.CorporationContract.CorporationID,
			&i.CorporationContract.Collateral,
			&i.CorporationContract.ContractID,
			&i.CorporationContract.DateAccepted,
			&i.CorporationContract.DateCompleted,
			&i.CorporationContract.DateExpired,
			&i.CorporationContract.DateIssued,
			&i.CorporationContract.DaysToComplete,
			&i.CorporationContract.EndLocationID,
			&i.CorporationContract.ForCorporation,
			&i.CorporationContract.IssuerCorporationID,
			&i.CorporationContract.IssuerID,
			&i.CorporationContract.Price,
			&i.CorporationContract.Reward,
			&i.CorporationContract.StartLocationID,
			&i.CorporationContract.Status,
			&i.CorporationContract.StatusNotified,
			&i.CorporationContract.Title,
			&i.CorporationContract.Type,
			&i.CorporationContract.UpdatedAt,
			&i.CorporationContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.EndSolarSystemSecurityStatus,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.StartSolarSystemSecurityStatus,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCorporationContract = `-- name: UpdateCorporationContract :exec
UPDATE
    corporation_contracts
SET
    acceptor_id = ?,
    date_accepted = ?,
    date_completed = ?,
    status = ?,
    updated_at = ?
WHERE
    corporation_id = ?
    AND contract_id = ?
`

type UpdateCorporationContractParams struct {
	AcceptorID    sql.NullInt64
	DateAccepted  sql.NullTime
	DateCompleted sql.NullTime
	Status        string
	UpdatedAt     time.Time
	CorporationID int64
	ContractID    int64
}

func (q *Queries) UpdateCorporationContract(ctx context.Context, arg UpdateCorporationContractParams) error {
	_, err := q.db.ExecContext(ctx, updateCorporationContract,
		arg.AcceptorID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.Status,
		arg.UpdatedAt,
		arg.CorporationID,
		arg.ContractID,
	)
	return err
}

const updateCorporationContractNotified = `-- name: UpdateCorporationContractNotified :exec
UPDATE
    corporation_contracts
SET
    status_notified = ?,
    updated_at = ?
WHERE
    id = ?
`

type UpdateCorporationContractNotifiedParams struct {
	StatusNotified string
	UpdatedAt      time.Time
	ID             int64
}

func (q *Queries) UpdateCorporationContractNotified(ctx context.Context, arg UpdateCorporationContractNotifiedParams) error {
	_, err := q.db.ExecContext(ctx, updateCorporationContractNotified, arg.StatusNotified, arg.UpdatedAt, arg.ID)
	return err
}
