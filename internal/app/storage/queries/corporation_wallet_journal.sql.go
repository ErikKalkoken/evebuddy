// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: corporation_wallet_journal.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCorporationWalletJournalEntry = `-- name: CreateCorporationWalletJournalEntry :exec
INSERT INTO
    corporation_wallet_journal_entries (
        amount,
        balance,
        context_id,
        context_id_type,
        date,
        description,
        division_id,
        first_party_id,
        ref_id,
        corporation_id,
        reason,
        ref_type,
        second_party_id,
        tax,
        tax_receiver_id
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateCorporationWalletJournalEntryParams struct {
	Amount        float64
	Balance       float64
	ContextID     int64
	ContextIDType string
	Date          time.Time
	Description   string
	DivisionID    int64
	FirstPartyID  sql.NullInt64
	RefID         int64
	CorporationID int64
	Reason        string
	RefType       string
	SecondPartyID sql.NullInt64
	Tax           float64
	TaxReceiverID sql.NullInt64
}

func (q *Queries) CreateCorporationWalletJournalEntry(ctx context.Context, arg CreateCorporationWalletJournalEntryParams) error {
	_, err := q.db.ExecContext(ctx, createCorporationWalletJournalEntry,
		arg.Amount,
		arg.Balance,
		arg.ContextID,
		arg.ContextIDType,
		arg.Date,
		arg.Description,
		arg.DivisionID,
		arg.FirstPartyID,
		arg.RefID,
		arg.CorporationID,
		arg.Reason,
		arg.RefType,
		arg.SecondPartyID,
		arg.Tax,
		arg.TaxReceiverID,
	)
	return err
}

const getCorporationWalletJournalEntry = `-- name: GetCorporationWalletJournalEntry :one
SELECT
    wje.id, wje.amount, wje.balance, wje.corporation_id, wje.context_id, wje.context_id_type, wje.date, wje.description, wje.division_id, wje.first_party_id, wje.ref_id, wje.reason, wje.ref_type, wje.second_party_id, wje.tax, wje.tax_receiver_id,
    fp.name as first_name,
    fp.category as first_category,
    sp.name as second_name,
    sp.category as second_category,
    tr.name as tax_name,
    tr.category as tax_category
FROM
    corporation_wallet_journal_entries wje
    LEFT JOIN eve_entities AS fp ON fp.id = wje.first_party_id
    LEFT JOIN eve_entities AS sp ON sp.id = wje.second_party_id
    LEFT JOIN eve_entities AS tr ON tr.id = wje.tax_receiver_id
WHERE
    corporation_id = ?
    AND wje.ref_id = ?
    and wje.division_id = ?
`

type GetCorporationWalletJournalEntryParams struct {
	CorporationID int64
	RefID         int64
	DivisionID    int64
}

type GetCorporationWalletJournalEntryRow struct {
	CorporationWalletJournalEntry CorporationWalletJournalEntry
	FirstName                     sql.NullString
	FirstCategory                 sql.NullString
	SecondName                    sql.NullString
	SecondCategory                sql.NullString
	TaxName                       sql.NullString
	TaxCategory                   sql.NullString
}

func (q *Queries) GetCorporationWalletJournalEntry(ctx context.Context, arg GetCorporationWalletJournalEntryParams) (GetCorporationWalletJournalEntryRow, error) {
	row := q.db.QueryRowContext(ctx, getCorporationWalletJournalEntry, arg.CorporationID, arg.RefID, arg.DivisionID)
	var i GetCorporationWalletJournalEntryRow
	err := row.Scan(
		&i.CorporationWalletJournalEntry.ID,
		&i.CorporationWalletJournalEntry.Amount,
		&i.CorporationWalletJournalEntry.Balance,
		&i.CorporationWalletJournalEntry.CorporationID,
		&i.CorporationWalletJournalEntry.ContextID,
		&i.CorporationWalletJournalEntry.ContextIDType,
		&i.CorporationWalletJournalEntry.Date,
		&i.CorporationWalletJournalEntry.Description,
		&i.CorporationWalletJournalEntry.DivisionID,
		&i.CorporationWalletJournalEntry.FirstPartyID,
		&i.CorporationWalletJournalEntry.RefID,
		&i.CorporationWalletJournalEntry.Reason,
		&i.CorporationWalletJournalEntry.RefType,
		&i.CorporationWalletJournalEntry.SecondPartyID,
		&i.CorporationWalletJournalEntry.Tax,
		&i.CorporationWalletJournalEntry.TaxReceiverID,
		&i.FirstName,
		&i.FirstCategory,
		&i.SecondName,
		&i.SecondCategory,
		&i.TaxName,
		&i.TaxCategory,
	)
	return i, err
}

const listCorporationWalletJournalEntries = `-- name: ListCorporationWalletJournalEntries :many
SELECT
    wje.id, wje.amount, wje.balance, wje.corporation_id, wje.context_id, wje.context_id_type, wje.date, wje.description, wje.division_id, wje.first_party_id, wje.ref_id, wje.reason, wje.ref_type, wje.second_party_id, wje.tax, wje.tax_receiver_id,
    fp.name as first_name,
    fp.category as first_category,
    sp.name as second_name,
    sp.category as second_category,
    tr.name as tax_name,
    tr.category as tax_category
FROM
    corporation_wallet_journal_entries wje
    LEFT JOIN eve_entities AS fp ON fp.id = wje.first_party_id
    LEFT JOIN eve_entities AS sp ON sp.id = wje.second_party_id
    LEFT JOIN eve_entities AS tr ON tr.id = wje.tax_receiver_id
WHERE
    corporation_id = ?
    AND division_id = ?
ORDER BY
    date DESC
`

type ListCorporationWalletJournalEntriesParams struct {
	CorporationID int64
	DivisionID    int64
}

type ListCorporationWalletJournalEntriesRow struct {
	CorporationWalletJournalEntry CorporationWalletJournalEntry
	FirstName                     sql.NullString
	FirstCategory                 sql.NullString
	SecondName                    sql.NullString
	SecondCategory                sql.NullString
	TaxName                       sql.NullString
	TaxCategory                   sql.NullString
}

func (q *Queries) ListCorporationWalletJournalEntries(ctx context.Context, arg ListCorporationWalletJournalEntriesParams) ([]ListCorporationWalletJournalEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationWalletJournalEntries, arg.CorporationID, arg.DivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCorporationWalletJournalEntriesRow
	for rows.Next() {
		var i ListCorporationWalletJournalEntriesRow
		if err := rows.Scan(
			&i.CorporationWalletJournalEntry.ID,
			&i.CorporationWalletJournalEntry.Amount,
			&i.CorporationWalletJournalEntry.Balance,
			&i.CorporationWalletJournalEntry.CorporationID,
			&i.CorporationWalletJournalEntry.ContextID,
			&i.CorporationWalletJournalEntry.ContextIDType,
			&i.CorporationWalletJournalEntry.Date,
			&i.CorporationWalletJournalEntry.Description,
			&i.CorporationWalletJournalEntry.DivisionID,
			&i.CorporationWalletJournalEntry.FirstPartyID,
			&i.CorporationWalletJournalEntry.RefID,
			&i.CorporationWalletJournalEntry.Reason,
			&i.CorporationWalletJournalEntry.RefType,
			&i.CorporationWalletJournalEntry.SecondPartyID,
			&i.CorporationWalletJournalEntry.Tax,
			&i.CorporationWalletJournalEntry.TaxReceiverID,
			&i.FirstName,
			&i.FirstCategory,
			&i.SecondName,
			&i.SecondCategory,
			&i.TaxName,
			&i.TaxCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorporationWalletJournalEntryRefIDs = `-- name: ListCorporationWalletJournalEntryRefIDs :many
SELECT
    ref_id
FROM
    corporation_wallet_journal_entries
WHERE
    corporation_id = ?
    AND division_id = ?
`

type ListCorporationWalletJournalEntryRefIDsParams struct {
	CorporationID int64
	DivisionID    int64
}

func (q *Queries) ListCorporationWalletJournalEntryRefIDs(ctx context.Context, arg ListCorporationWalletJournalEntryRefIDsParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCorporationWalletJournalEntryRefIDs, arg.CorporationID, arg.DivisionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var ref_id int64
		if err := rows.Scan(&ref_id); err != nil {
			return nil, err
		}
		items = append(items, ref_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
