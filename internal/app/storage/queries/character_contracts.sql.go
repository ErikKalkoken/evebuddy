// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: character_contracts.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createCharacterContract = `-- name: CreateCharacterContract :one
INSERT INTO
    character_contracts (
        acceptor_id,
        assignee_id,
        availability,
        buyout,
        character_id,
        collateral,
        contract_id,
        date_accepted,
        date_completed,
        date_expired,
        date_issued,
        days_to_complete,
        end_location_id,
        for_corporation,
        issuer_corporation_id,
        issuer_id,
        price,
        reward,
        start_location_id,
        status,
        status_notified,
        title,
        type,
        updated_at,
        volume
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    ) RETURNING id
`

type CreateCharacterContractParams struct {
	AcceptorID          sql.NullInt64
	AssigneeID          sql.NullInt64
	Availability        string
	Buyout              float64
	CharacterID         int64
	Collateral          float64
	ContractID          int64
	DateAccepted        sql.NullTime
	DateCompleted       sql.NullTime
	DateExpired         time.Time
	DateIssued          time.Time
	DaysToComplete      int64
	EndLocationID       sql.NullInt64
	ForCorporation      bool
	IssuerCorporationID int64
	IssuerID            int64
	Price               float64
	Reward              float64
	StartLocationID     sql.NullInt64
	Status              string
	StatusNotified      string
	Title               string
	Type                string
	UpdatedAt           time.Time
	Volume              float64
}

func (q *Queries) CreateCharacterContract(ctx context.Context, arg CreateCharacterContractParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createCharacterContract,
		arg.AcceptorID,
		arg.AssigneeID,
		arg.Availability,
		arg.Buyout,
		arg.CharacterID,
		arg.Collateral,
		arg.ContractID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.DateExpired,
		arg.DateIssued,
		arg.DaysToComplete,
		arg.EndLocationID,
		arg.ForCorporation,
		arg.IssuerCorporationID,
		arg.IssuerID,
		arg.Price,
		arg.Reward,
		arg.StartLocationID,
		arg.Status,
		arg.StatusNotified,
		arg.Title,
		arg.Type,
		arg.UpdatedAt,
		arg.Volume,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCharacterContract = `-- name: GetCharacterContract :one
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
            AND cci.is_included IS TRUE
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    character_id = ?
    AND cc.contract_id = ?
`

type GetCharacterContractParams struct {
	CharacterID int64
	ContractID  int64
}

type GetCharacterContractRow struct {
	CharacterContract    CharacterContract
	EveEntity            EveEntity
	EveEntity_2          EveEntity
	AcceptorName         sql.NullString
	AcceptorCategory     sql.NullString
	AssigneeName         sql.NullString
	AssigneeCategory     sql.NullString
	EndLocationName      sql.NullString
	StartLocationName    sql.NullString
	EndSolarSystemID     sql.NullInt64
	EndSolarSystemName   sql.NullString
	StartSolarSystemID   sql.NullInt64
	StartSolarSystemName sql.NullString
	Items                interface{}
}

func (q *Queries) GetCharacterContract(ctx context.Context, arg GetCharacterContractParams) (GetCharacterContractRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterContract, arg.CharacterID, arg.ContractID)
	var i GetCharacterContractRow
	err := row.Scan(
		&i.CharacterContract.ID,
		&i.CharacterContract.AcceptorID,
		&i.CharacterContract.AssigneeID,
		&i.CharacterContract.Availability,
		&i.CharacterContract.Buyout,
		&i.CharacterContract.CharacterID,
		&i.CharacterContract.Collateral,
		&i.CharacterContract.ContractID,
		&i.CharacterContract.DateAccepted,
		&i.CharacterContract.DateCompleted,
		&i.CharacterContract.DateExpired,
		&i.CharacterContract.DateIssued,
		&i.CharacterContract.DaysToComplete,
		&i.CharacterContract.EndLocationID,
		&i.CharacterContract.ForCorporation,
		&i.CharacterContract.IssuerCorporationID,
		&i.CharacterContract.IssuerID,
		&i.CharacterContract.Price,
		&i.CharacterContract.Reward,
		&i.CharacterContract.StartLocationID,
		&i.CharacterContract.Status,
		&i.CharacterContract.StatusNotified,
		&i.CharacterContract.Title,
		&i.CharacterContract.Type,
		&i.CharacterContract.UpdatedAt,
		&i.CharacterContract.Volume,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveEntity_2.ID,
		&i.EveEntity_2.Category,
		&i.EveEntity_2.Name,
		&i.AcceptorName,
		&i.AcceptorCategory,
		&i.AssigneeName,
		&i.AssigneeCategory,
		&i.EndLocationName,
		&i.StartLocationName,
		&i.EndSolarSystemID,
		&i.EndSolarSystemName,
		&i.StartSolarSystemID,
		&i.StartSolarSystemName,
		&i.Items,
	)
	return i, err
}

const listAllCharacterContracts = `-- name: ListAllCharacterContracts :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
            AND cci.is_included IS TRUE
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    status <> "deleted"
GROUP BY
    contract_id
ORDER BY
    date_issued DESC
`

type ListAllCharacterContractsRow struct {
	CharacterContract    CharacterContract
	EveEntity            EveEntity
	EveEntity_2          EveEntity
	AcceptorName         sql.NullString
	AcceptorCategory     sql.NullString
	AssigneeName         sql.NullString
	AssigneeCategory     sql.NullString
	EndLocationName      sql.NullString
	StartLocationName    sql.NullString
	EndSolarSystemID     sql.NullInt64
	EndSolarSystemName   sql.NullString
	StartSolarSystemID   sql.NullInt64
	StartSolarSystemName sql.NullString
	Items                interface{}
}

func (q *Queries) ListAllCharacterContracts(ctx context.Context) ([]ListAllCharacterContractsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterContracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterContractsRow
	for rows.Next() {
		var i ListAllCharacterContractsRow
		if err := rows.Scan(
			&i.CharacterContract.ID,
			&i.CharacterContract.AcceptorID,
			&i.CharacterContract.AssigneeID,
			&i.CharacterContract.Availability,
			&i.CharacterContract.Buyout,
			&i.CharacterContract.CharacterID,
			&i.CharacterContract.Collateral,
			&i.CharacterContract.ContractID,
			&i.CharacterContract.DateAccepted,
			&i.CharacterContract.DateCompleted,
			&i.CharacterContract.DateExpired,
			&i.CharacterContract.DateIssued,
			&i.CharacterContract.DaysToComplete,
			&i.CharacterContract.EndLocationID,
			&i.CharacterContract.ForCorporation,
			&i.CharacterContract.IssuerCorporationID,
			&i.CharacterContract.IssuerID,
			&i.CharacterContract.Price,
			&i.CharacterContract.Reward,
			&i.CharacterContract.StartLocationID,
			&i.CharacterContract.Status,
			&i.CharacterContract.StatusNotified,
			&i.CharacterContract.Title,
			&i.CharacterContract.Type,
			&i.CharacterContract.UpdatedAt,
			&i.CharacterContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractIDs = `-- name: ListCharacterContractIDs :many
SELECT
    contract_id
FROM
    character_contracts
WHERE
    character_id = ?
`

func (q *Queries) ListCharacterContractIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var contract_id int64
		if err := rows.Scan(&contract_id); err != nil {
			return nil, err
		}
		items = append(items, contract_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractsForNotify = `-- name: ListCharacterContractsForNotify :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
            AND cci.is_included IS TRUE
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    character_id = ?
    AND status <> "deleted"
    AND cc.updated_at > ?
`

type ListCharacterContractsForNotifyParams struct {
	CharacterID int64
	UpdatedAt   time.Time
}

type ListCharacterContractsForNotifyRow struct {
	CharacterContract    CharacterContract
	EveEntity            EveEntity
	EveEntity_2          EveEntity
	AcceptorName         sql.NullString
	AcceptorCategory     sql.NullString
	AssigneeName         sql.NullString
	AssigneeCategory     sql.NullString
	EndLocationName      sql.NullString
	StartLocationName    sql.NullString
	EndSolarSystemID     sql.NullInt64
	EndSolarSystemName   sql.NullString
	StartSolarSystemID   sql.NullInt64
	StartSolarSystemName sql.NullString
	Items                interface{}
}

func (q *Queries) ListCharacterContractsForNotify(ctx context.Context, arg ListCharacterContractsForNotifyParams) ([]ListCharacterContractsForNotifyRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractsForNotify, arg.CharacterID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterContractsForNotifyRow
	for rows.Next() {
		var i ListCharacterContractsForNotifyRow
		if err := rows.Scan(
			&i.CharacterContract.ID,
			&i.CharacterContract.AcceptorID,
			&i.CharacterContract.AssigneeID,
			&i.CharacterContract.Availability,
			&i.CharacterContract.Buyout,
			&i.CharacterContract.CharacterID,
			&i.CharacterContract.Collateral,
			&i.CharacterContract.ContractID,
			&i.CharacterContract.DateAccepted,
			&i.CharacterContract.DateCompleted,
			&i.CharacterContract.DateExpired,
			&i.CharacterContract.DateIssued,
			&i.CharacterContract.DaysToComplete,
			&i.CharacterContract.EndLocationID,
			&i.CharacterContract.ForCorporation,
			&i.CharacterContract.IssuerCorporationID,
			&i.CharacterContract.IssuerID,
			&i.CharacterContract.Price,
			&i.CharacterContract.Reward,
			&i.CharacterContract.StartLocationID,
			&i.CharacterContract.Status,
			&i.CharacterContract.StatusNotified,
			&i.CharacterContract.Title,
			&i.CharacterContract.Type,
			&i.CharacterContract.UpdatedAt,
			&i.CharacterContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterContract = `-- name: UpdateCharacterContract :exec
UPDATE
    character_contracts
SET
    acceptor_id = ?,
    date_accepted = ?,
    date_completed = ?,
    status = ?,
    updated_at = ?
WHERE
    character_id = ?
    AND contract_id = ?
`

type UpdateCharacterContractParams struct {
	AcceptorID    sql.NullInt64
	DateAccepted  sql.NullTime
	DateCompleted sql.NullTime
	Status        string
	UpdatedAt     time.Time
	CharacterID   int64
	ContractID    int64
}

func (q *Queries) UpdateCharacterContract(ctx context.Context, arg UpdateCharacterContractParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterContract,
		arg.AcceptorID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.Status,
		arg.UpdatedAt,
		arg.CharacterID,
		arg.ContractID,
	)
	return err
}

const updateCharacterContractNotified = `-- name: UpdateCharacterContractNotified :exec
UPDATE
    character_contracts
SET
    status_notified = ?,
    updated_at = ?
WHERE
    id = ?
`

type UpdateCharacterContractNotifiedParams struct {
	StatusNotified string
	UpdatedAt      time.Time
	ID             int64
}

func (q *Queries) UpdateCharacterContractNotified(ctx context.Context, arg UpdateCharacterContractNotifiedParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterContractNotified, arg.StatusNotified, arg.UpdatedAt, arg.ID)
	return err
}
