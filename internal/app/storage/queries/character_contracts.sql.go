// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: character_contracts.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const createCharacterContract = `-- name: CreateCharacterContract :one
INSERT INTO
    character_contracts (
        acceptor_id,
        assignee_id,
        availability,
        buyout,
        character_id,
        collateral,
        contract_id,
        date_accepted,
        date_completed,
        date_expired,
        date_issued,
        days_to_complete,
        end_location_id,
        for_corporation,
        issuer_corporation_id,
        issuer_id,
        price,
        reward,
        start_location_id,
        status,
        status_notified,
        title,
        type,
        updated_at,
        volume
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
RETURNING
    id
`

type CreateCharacterContractParams struct {
	AcceptorID          sql.NullInt64
	AssigneeID          sql.NullInt64
	Availability        string
	Buyout              float64
	CharacterID         int64
	Collateral          float64
	ContractID          int64
	DateAccepted        sql.NullTime
	DateCompleted       sql.NullTime
	DateExpired         time.Time
	DateIssued          time.Time
	DaysToComplete      int64
	EndLocationID       sql.NullInt64
	ForCorporation      bool
	IssuerCorporationID int64
	IssuerID            int64
	Price               float64
	Reward              float64
	StartLocationID     sql.NullInt64
	Status              string
	StatusNotified      string
	Title               string
	Type                string
	UpdatedAt           time.Time
	Volume              float64
}

func (q *Queries) CreateCharacterContract(ctx context.Context, arg CreateCharacterContractParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createCharacterContract,
		arg.AcceptorID,
		arg.AssigneeID,
		arg.Availability,
		arg.Buyout,
		arg.CharacterID,
		arg.Collateral,
		arg.ContractID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.DateExpired,
		arg.DateIssued,
		arg.DaysToComplete,
		arg.EndLocationID,
		arg.ForCorporation,
		arg.IssuerCorporationID,
		arg.IssuerID,
		arg.Price,
		arg.Reward,
		arg.StartLocationID,
		arg.Status,
		arg.StatusNotified,
		arg.Title,
		arg.Type,
		arg.UpdatedAt,
		arg.Volume,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCharacterContractBid = `-- name: CreateCharacterContractBid :exec
INSERT INTO
    character_contract_bids (contract_id, amount, bid_id, bidder_id, date_bid)
VALUES
    (?, ?, ?, ?, ?)
`

type CreateCharacterContractBidParams struct {
	ContractID int64
	Amount     float64
	BidID      int64
	BidderID   int64
	DateBid    time.Time
}

func (q *Queries) CreateCharacterContractBid(ctx context.Context, arg CreateCharacterContractBidParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterContractBid,
		arg.ContractID,
		arg.Amount,
		arg.BidID,
		arg.BidderID,
		arg.DateBid,
	)
	return err
}

const createCharacterContractItem = `-- name: CreateCharacterContractItem :exec
INSERT INTO
    character_contract_items (
        contract_id,
        is_included,
        is_singleton,
        quantity,
        raw_quantity,
        record_id,
        type_id
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?)
`

type CreateCharacterContractItemParams struct {
	ContractID  int64
	IsIncluded  bool
	IsSingleton bool
	Quantity    int64
	RawQuantity int64
	RecordID    int64
	TypeID      int64
}

func (q *Queries) CreateCharacterContractItem(ctx context.Context, arg CreateCharacterContractItemParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterContractItem,
		arg.ContractID,
		arg.IsIncluded,
		arg.IsSingleton,
		arg.Quantity,
		arg.RawQuantity,
		arg.RecordID,
		arg.TypeID,
	)
	return err
}

const deleteCharacterContracts = `-- name: DeleteCharacterContracts :exec
DELETE FROM character_contracts
WHERE character_id = ?
AND contract_id IN (/*SLICE:contract_ids*/?)
`

type DeleteCharacterContractsParams struct {
	CharacterID int64
	ContractIds []int64
}

func (q *Queries) DeleteCharacterContracts(ctx context.Context, arg DeleteCharacterContractsParams) error {
	query := deleteCharacterContracts
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.ContractIds) > 0 {
		for _, v := range arg.ContractIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:contract_ids*/?", strings.Repeat(",?", len(arg.ContractIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:contract_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCharacterContract = `-- name: GetCharacterContract :one
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    character_id = ?
    AND cc.contract_id = ?
`

type GetCharacterContractParams struct {
	CharacterID int64
	ContractID  int64
}

type GetCharacterContractRow struct {
	CharacterContract              CharacterContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) GetCharacterContract(ctx context.Context, arg GetCharacterContractParams) (GetCharacterContractRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterContract, arg.CharacterID, arg.ContractID)
	var i GetCharacterContractRow
	err := row.Scan(
		&i.CharacterContract.ID,
		&i.CharacterContract.AcceptorID,
		&i.CharacterContract.AssigneeID,
		&i.CharacterContract.Availability,
		&i.CharacterContract.Buyout,
		&i.CharacterContract.CharacterID,
		&i.CharacterContract.Collateral,
		&i.CharacterContract.ContractID,
		&i.CharacterContract.DateAccepted,
		&i.CharacterContract.DateCompleted,
		&i.CharacterContract.DateExpired,
		&i.CharacterContract.DateIssued,
		&i.CharacterContract.DaysToComplete,
		&i.CharacterContract.EndLocationID,
		&i.CharacterContract.ForCorporation,
		&i.CharacterContract.IssuerCorporationID,
		&i.CharacterContract.IssuerID,
		&i.CharacterContract.Price,
		&i.CharacterContract.Reward,
		&i.CharacterContract.StartLocationID,
		&i.CharacterContract.Status,
		&i.CharacterContract.StatusNotified,
		&i.CharacterContract.Title,
		&i.CharacterContract.Type,
		&i.CharacterContract.UpdatedAt,
		&i.CharacterContract.Volume,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
		&i.EveEntity_2.ID,
		&i.EveEntity_2.Category,
		&i.EveEntity_2.Name,
		&i.AcceptorName,
		&i.AcceptorCategory,
		&i.AssigneeName,
		&i.AssigneeCategory,
		&i.EndLocationName,
		&i.StartLocationName,
		&i.EndSolarSystemID,
		&i.EndSolarSystemName,
		&i.EndSolarSystemSecurityStatus,
		&i.StartSolarSystemID,
		&i.StartSolarSystemName,
		&i.StartSolarSystemSecurityStatus,
		&i.Items,
	)
	return i, err
}

const getCharacterContractBid = `-- name: GetCharacterContractBid :one
SELECT
    ccb.id, ccb.contract_id, ccb.amount, ccb.bid_id, ccb.bidder_id, ccb.date_bid,
    ee.id, ee.category, ee.name
FROM
    character_contract_bids ccb
    JOIN eve_entities ee ON ee.id = ccb.bidder_id
WHERE
    contract_id = ?
    AND bid_id = ?
`

type GetCharacterContractBidParams struct {
	ContractID int64
	BidID      int64
}

type GetCharacterContractBidRow struct {
	CharacterContractBid CharacterContractBid
	EveEntity            EveEntity
}

func (q *Queries) GetCharacterContractBid(ctx context.Context, arg GetCharacterContractBidParams) (GetCharacterContractBidRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterContractBid, arg.ContractID, arg.BidID)
	var i GetCharacterContractBidRow
	err := row.Scan(
		&i.CharacterContractBid.ID,
		&i.CharacterContractBid.ContractID,
		&i.CharacterContractBid.Amount,
		&i.CharacterContractBid.BidID,
		&i.CharacterContractBid.BidderID,
		&i.CharacterContractBid.DateBid,
		&i.EveEntity.ID,
		&i.EveEntity.Category,
		&i.EveEntity.Name,
	)
	return i, err
}

const getCharacterContractItem = `-- name: GetCharacterContractItem :one
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    character_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
    AND record_id = ?
`

type GetCharacterContractItemParams struct {
	ContractID int64
	RecordID   int64
}

type GetCharacterContractItemRow struct {
	CharacterContractItem CharacterContractItem
	EveType               EveType
	EveGroup              EveGroup
	EveCategory           EveCategory
}

func (q *Queries) GetCharacterContractItem(ctx context.Context, arg GetCharacterContractItemParams) (GetCharacterContractItemRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterContractItem, arg.ContractID, arg.RecordID)
	var i GetCharacterContractItemRow
	err := row.Scan(
		&i.CharacterContractItem.ID,
		&i.CharacterContractItem.ContractID,
		&i.CharacterContractItem.IsIncluded,
		&i.CharacterContractItem.IsSingleton,
		&i.CharacterContractItem.Quantity,
		&i.CharacterContractItem.RawQuantity,
		&i.CharacterContractItem.RecordID,
		&i.CharacterContractItem.TypeID,
		&i.EveType.ID,
		&i.EveType.EveGroupID,
		&i.EveType.Capacity,
		&i.EveType.Description,
		&i.EveType.GraphicID,
		&i.EveType.IconID,
		&i.EveType.IsPublished,
		&i.EveType.MarketGroupID,
		&i.EveType.Mass,
		&i.EveType.Name,
		&i.EveType.PackagedVolume,
		&i.EveType.PortionSize,
		&i.EveType.Radius,
		&i.EveType.Volume,
		&i.EveGroup.ID,
		&i.EveGroup.EveCategoryID,
		&i.EveGroup.Name,
		&i.EveGroup.IsPublished,
		&i.EveCategory.ID,
		&i.EveCategory.Name,
		&i.EveCategory.IsPublished,
	)
	return i, err
}

const listAllCharacterContracts = `-- name: ListAllCharacterContracts :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
GROUP BY
    character_id,
    contract_id
ORDER BY
    date_issued DESC
`

type ListAllCharacterContractsRow struct {
	CharacterContract              CharacterContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) ListAllCharacterContracts(ctx context.Context) ([]ListAllCharacterContractsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllCharacterContracts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCharacterContractsRow
	for rows.Next() {
		var i ListAllCharacterContractsRow
		if err := rows.Scan(
			&i.CharacterContract.ID,
			&i.CharacterContract.AcceptorID,
			&i.CharacterContract.AssigneeID,
			&i.CharacterContract.Availability,
			&i.CharacterContract.Buyout,
			&i.CharacterContract.CharacterID,
			&i.CharacterContract.Collateral,
			&i.CharacterContract.ContractID,
			&i.CharacterContract.DateAccepted,
			&i.CharacterContract.DateCompleted,
			&i.CharacterContract.DateExpired,
			&i.CharacterContract.DateIssued,
			&i.CharacterContract.DaysToComplete,
			&i.CharacterContract.EndLocationID,
			&i.CharacterContract.ForCorporation,
			&i.CharacterContract.IssuerCorporationID,
			&i.CharacterContract.IssuerID,
			&i.CharacterContract.Price,
			&i.CharacterContract.Reward,
			&i.CharacterContract.StartLocationID,
			&i.CharacterContract.Status,
			&i.CharacterContract.StatusNotified,
			&i.CharacterContract.Title,
			&i.CharacterContract.Type,
			&i.CharacterContract.UpdatedAt,
			&i.CharacterContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.EndSolarSystemSecurityStatus,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.StartSolarSystemSecurityStatus,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractBidIDs = `-- name: ListCharacterContractBidIDs :many
SELECT
    bid_id
FROM
    character_contract_bids
WHERE
    contract_id = ?
`

func (q *Queries) ListCharacterContractBidIDs(ctx context.Context, contractID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractBidIDs, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var bid_id int64
		if err := rows.Scan(&bid_id); err != nil {
			return nil, err
		}
		items = append(items, bid_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractBids = `-- name: ListCharacterContractBids :many
SELECT
    ccb.id, ccb.contract_id, ccb.amount, ccb.bid_id, ccb.bidder_id, ccb.date_bid,
    ee.id, ee.category, ee.name
FROM
    character_contract_bids ccb
    JOIN eve_entities ee ON ee.id = ccb.bidder_id
WHERE
    contract_id = ?
`

type ListCharacterContractBidsRow struct {
	CharacterContractBid CharacterContractBid
	EveEntity            EveEntity
}

func (q *Queries) ListCharacterContractBids(ctx context.Context, contractID int64) ([]ListCharacterContractBidsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractBids, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterContractBidsRow
	for rows.Next() {
		var i ListCharacterContractBidsRow
		if err := rows.Scan(
			&i.CharacterContractBid.ID,
			&i.CharacterContractBid.ContractID,
			&i.CharacterContractBid.Amount,
			&i.CharacterContractBid.BidID,
			&i.CharacterContractBid.BidderID,
			&i.CharacterContractBid.DateBid,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractIDs = `-- name: ListCharacterContractIDs :many
SELECT
    contract_id
FROM
    character_contracts
WHERE
    character_id = ?
`

func (q *Queries) ListCharacterContractIDs(ctx context.Context, characterID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractIDs, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var contract_id int64
		if err := rows.Scan(&contract_id); err != nil {
			return nil, err
		}
		items = append(items, contract_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContractItems = `-- name: ListCharacterContractItems :many
SELECT
    cci.id, cci.contract_id, cci.is_included, cci.is_singleton, cci.quantity, cci.raw_quantity, cci.record_id, cci.type_id,
    et.id, et.eve_group_id, et.capacity, et.description, et.graphic_id, et.icon_id, et.is_published, et.market_group_id, et.mass, et.name, et.packaged_volume, et.portion_size, et.radius, et.volume,
    eg.id, eg.eve_category_id, eg.name, eg.is_published,
    ec.id, ec.name, ec.is_published
FROM
    character_contract_items cci
    JOIN eve_types et ON et.id = cci.type_id
    JOIN eve_groups eg ON eg.id = et.eve_group_id
    JOIN eve_categories ec ON ec.id = eg.eve_category_id
WHERE
    contract_id = ?
`

type ListCharacterContractItemsRow struct {
	CharacterContractItem CharacterContractItem
	EveType               EveType
	EveGroup              EveGroup
	EveCategory           EveCategory
}

func (q *Queries) ListCharacterContractItems(ctx context.Context, contractID int64) ([]ListCharacterContractItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContractItems, contractID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterContractItemsRow
	for rows.Next() {
		var i ListCharacterContractItemsRow
		if err := rows.Scan(
			&i.CharacterContractItem.ID,
			&i.CharacterContractItem.ContractID,
			&i.CharacterContractItem.IsIncluded,
			&i.CharacterContractItem.IsSingleton,
			&i.CharacterContractItem.Quantity,
			&i.CharacterContractItem.RawQuantity,
			&i.CharacterContractItem.RecordID,
			&i.CharacterContractItem.TypeID,
			&i.EveType.ID,
			&i.EveType.EveGroupID,
			&i.EveType.Capacity,
			&i.EveType.Description,
			&i.EveType.GraphicID,
			&i.EveType.IconID,
			&i.EveType.IsPublished,
			&i.EveType.MarketGroupID,
			&i.EveType.Mass,
			&i.EveType.Name,
			&i.EveType.PackagedVolume,
			&i.EveType.PortionSize,
			&i.EveType.Radius,
			&i.EveType.Volume,
			&i.EveGroup.ID,
			&i.EveGroup.EveCategoryID,
			&i.EveGroup.Name,
			&i.EveGroup.IsPublished,
			&i.EveCategory.ID,
			&i.EveCategory.Name,
			&i.EveCategory.IsPublished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacterContracts = `-- name: ListCharacterContracts :many
SELECT
    cc.id, cc.acceptor_id, cc.assignee_id, cc.availability, cc.buyout, cc.character_id, cc.collateral, cc.contract_id, cc.date_accepted, cc.date_completed, cc.date_expired, cc.date_issued, cc.days_to_complete, cc.end_location_id, cc.for_corporation, cc.issuer_corporation_id, cc.issuer_id, cc.price, cc.reward, cc.start_location_id, cc.status, cc.status_notified, cc.title, cc.type, cc.updated_at, cc.volume,
    issuer_corporation.id, issuer_corporation.category, issuer_corporation.name,
    issuer.id, issuer.category, issuer.name,
    acceptor.name as acceptor_name,
    acceptor.category as acceptor_category,
    assignee.name as assignee_name,
    assignee.category as assignee_category,
    end_locations.name as end_location_name,
    start_locations.name as start_location_name,
    end_solar_systems.id as end_solar_system_id,
    end_solar_systems.name as end_solar_system_name,
    end_solar_systems.security_status as end_solar_system_security_status,
    start_solar_systems.id as start_solar_system_id,
    start_solar_systems.name as start_solar_system_name,
    start_solar_systems.security_status as start_solar_system_security_status,
    (
        SELECT
            IFNULL(GROUP_CONCAT(name || " x " || quantity), "")
        FROM
            character_contract_items cci
            LEFT JOIN eve_types et ON et.id = cci.type_id
        WHERE
            cci.contract_id = cc.id
    ) as items
FROM
    character_contracts cc
    JOIN eve_entities AS issuer_corporation ON issuer_corporation.id = cc.issuer_corporation_id
    JOIN eve_entities AS issuer ON issuer.id = cc.issuer_id
    LEFT JOIN eve_entities AS acceptor ON acceptor.id = cc.acceptor_id
    LEFT JOIN eve_entities AS assignee ON assignee.id = cc.assignee_id
    LEFT JOIN eve_locations AS end_locations ON end_locations.id = cc.end_location_id
    LEFT JOIN eve_locations AS start_locations ON start_locations.id = cc.start_location_id
    LEFT JOIN eve_solar_systems AS end_solar_systems ON end_solar_systems.id = end_locations.eve_solar_system_id
    LEFT JOIN eve_solar_systems AS start_solar_systems ON start_solar_systems.id = start_locations.eve_solar_system_id
WHERE
    character_id = ?
`

type ListCharacterContractsRow struct {
	CharacterContract              CharacterContract
	EveEntity                      EveEntity
	EveEntity_2                    EveEntity
	AcceptorName                   sql.NullString
	AcceptorCategory               sql.NullString
	AssigneeName                   sql.NullString
	AssigneeCategory               sql.NullString
	EndLocationName                sql.NullString
	StartLocationName              sql.NullString
	EndSolarSystemID               sql.NullInt64
	EndSolarSystemName             sql.NullString
	EndSolarSystemSecurityStatus   sql.NullFloat64
	StartSolarSystemID             sql.NullInt64
	StartSolarSystemName           sql.NullString
	StartSolarSystemSecurityStatus sql.NullFloat64
	Items                          interface{}
}

func (q *Queries) ListCharacterContracts(ctx context.Context, characterID int64) ([]ListCharacterContractsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterContracts, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterContractsRow
	for rows.Next() {
		var i ListCharacterContractsRow
		if err := rows.Scan(
			&i.CharacterContract.ID,
			&i.CharacterContract.AcceptorID,
			&i.CharacterContract.AssigneeID,
			&i.CharacterContract.Availability,
			&i.CharacterContract.Buyout,
			&i.CharacterContract.CharacterID,
			&i.CharacterContract.Collateral,
			&i.CharacterContract.ContractID,
			&i.CharacterContract.DateAccepted,
			&i.CharacterContract.DateCompleted,
			&i.CharacterContract.DateExpired,
			&i.CharacterContract.DateIssued,
			&i.CharacterContract.DaysToComplete,
			&i.CharacterContract.EndLocationID,
			&i.CharacterContract.ForCorporation,
			&i.CharacterContract.IssuerCorporationID,
			&i.CharacterContract.IssuerID,
			&i.CharacterContract.Price,
			&i.CharacterContract.Reward,
			&i.CharacterContract.StartLocationID,
			&i.CharacterContract.Status,
			&i.CharacterContract.StatusNotified,
			&i.CharacterContract.Title,
			&i.CharacterContract.Type,
			&i.CharacterContract.UpdatedAt,
			&i.CharacterContract.Volume,
			&i.EveEntity.ID,
			&i.EveEntity.Category,
			&i.EveEntity.Name,
			&i.EveEntity_2.ID,
			&i.EveEntity_2.Category,
			&i.EveEntity_2.Name,
			&i.AcceptorName,
			&i.AcceptorCategory,
			&i.AssigneeName,
			&i.AssigneeCategory,
			&i.EndLocationName,
			&i.StartLocationName,
			&i.EndSolarSystemID,
			&i.EndSolarSystemName,
			&i.EndSolarSystemSecurityStatus,
			&i.StartSolarSystemID,
			&i.StartSolarSystemName,
			&i.StartSolarSystemSecurityStatus,
			&i.Items,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharacterContract = `-- name: UpdateCharacterContract :exec
UPDATE character_contracts
SET
    acceptor_id = ?,
    date_accepted = ?,
    date_completed = ?,
    status = ?,
    updated_at = ?
WHERE
    character_id = ?
    AND contract_id = ?
`

type UpdateCharacterContractParams struct {
	AcceptorID    sql.NullInt64
	DateAccepted  sql.NullTime
	DateCompleted sql.NullTime
	Status        string
	UpdatedAt     time.Time
	CharacterID   int64
	ContractID    int64
}

func (q *Queries) UpdateCharacterContract(ctx context.Context, arg UpdateCharacterContractParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterContract,
		arg.AcceptorID,
		arg.DateAccepted,
		arg.DateCompleted,
		arg.Status,
		arg.UpdatedAt,
		arg.CharacterID,
		arg.ContractID,
	)
	return err
}

const updateCharacterContractNotified = `-- name: UpdateCharacterContractNotified :exec
UPDATE character_contracts
SET
    status_notified = ?,
    updated_at = ?
WHERE
    id = ?
`

type UpdateCharacterContractNotifiedParams struct {
	StatusNotified string
	UpdatedAt      time.Time
	ID             int64
}

func (q *Queries) UpdateCharacterContractNotified(ctx context.Context, arg UpdateCharacterContractNotifiedParams) error {
	_, err := q.db.ExecContext(ctx, updateCharacterContractNotified, arg.StatusNotified, arg.UpdatedAt, arg.ID)
	return err
}
