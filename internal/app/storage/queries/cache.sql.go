// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cache.sql

package queries

import (
	"context"
	"database/sql"
)

const cacheCleanUp = `-- name: CacheCleanUp :execrows
DELETE FROM
    cache
WHERE
    expires_at < ?1
`

func (q *Queries) CacheCleanUp(ctx context.Context, now sql.NullTime) (int64, error) {
	result, err := q.db.ExecContext(ctx, cacheCleanUp, now)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const cacheClear = `-- name: CacheClear :exec
DELETE FROM
    cache
`

func (q *Queries) CacheClear(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cacheClear)
	return err
}

const cacheDelete = `-- name: CacheDelete :exec
DELETE FROM
    cache
WHERE
    key = ?
`

func (q *Queries) CacheDelete(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, cacheDelete, key)
	return err
}

const cacheGet = `-- name: CacheGet :one
SELECT
    id, created_at, expires_at, "key", value
FROM
    cache
WHERE
    key = ?
    AND (
        expires_at > ?2
        OR expires_at IS NULL
    )
`

type CacheGetParams struct {
	Key string
	Now sql.NullTime
}

func (q *Queries) CacheGet(ctx context.Context, arg CacheGetParams) (Cache, error) {
	row := q.db.QueryRowContext(ctx, cacheGet, arg.Key, arg.Now)
	var i Cache
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Key,
		&i.Value,
	)
	return i, err
}

const cacheSet = `-- name: CacheSet :exec
INSERT INTO
    cache (
        expires_at,
        key,
        value
    )
VALUES
    (?1, ?2, ?3) ON CONFLICT(key) DO
UPDATE
SET
    expires_at = ?1,
    value = ?3
WHERE
    key = ?2
`

type CacheSetParams struct {
	ExpiresAt sql.NullTime
	Key       string
	Value     []byte
}

func (q *Queries) CacheSet(ctx context.Context, arg CacheSetParams) error {
	_, err := q.db.ExecContext(ctx, cacheSet, arg.ExpiresAt, arg.Key, arg.Value)
	return err
}
